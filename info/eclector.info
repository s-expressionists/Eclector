This is eclector.info, produced by makeinfo version 6.8 from
eclector.texi.

Copyright © 2010 - 2018 Robert Strandh Copyright © 2018 - 2023 Jan
Moringen
INFO-DIR-SECTION Common Lisp
START-INFO-DIR-ENTRY
* Eclector User’s Manual: (eclector). A portable Common Lisp reader.
END-INFO-DIR-ENTRY


File: eclector.info,  Node: Top,  Next: Introduction,  Up: (dir)

Eclector User’s Manual
**********************

This manual is for Eclector version 0.9.0.

* Menu:

* Introduction::
* External protocols::
* Recovering from errors::
* Side effects::
* Interpretation of unclear parts of the specification::
* Concept index::
* Function and macro and variable and type index::


File: eclector.info,  Node: Introduction,  Next: External protocols,  Prev: Top,  Up: Top

1 Introduction
**************

Eclector is a portable, implementation-independent version of the Common
Lisp function read, a corresponding readtable and a quasiquotation
facility.  As opposed to existing implementation-specific versions of
read, Eclector uses generic functions to allow clients to customize the
exact behavior, such as the interpretation of tokens.

   Another unusual feature of Eclector is its ability to, at the
discretion of the client, recover from many syntax errors, continue
reading and return a result that somewhat resembles what would have been
returned in case the syntax had been valid.

   Furthermore, Eclector can be used as a _source tracking_ reader,
which is accomplished through a mode of operation that produces _parse
results_ which wrap the Common Lisp expressions in objects that can also
contain information about the positions in the source code of those
expressions.  One example of such parse results are _concrete syntax
trees_ (1).

   ---------- Footnotes ----------

   (1) See: <https://github.com/s-expressionists/Concrete-Syntax-Tree>


File: eclector.info,  Node: External protocols,  Next: Recovering from errors,  Prev: Introduction,  Up: Top

2 External protocols
********************

* Menu:

* Packages::
* Basic features::
* Ordinary reader features::
* Readtable features::
* Parse result construction features::
* CST reader features::


File: eclector.info,  Node: Packages,  Next: Basic features,  Up: External protocols

2.1 Packages
============

* Menu:

* Package for basic features::
* Package for ordinary reader features::
* Package for readtable features::
* Package for parse result construction features::
* Package for CST features::


File: eclector.info,  Node: Package for basic features,  Next: Package for ordinary reader features,  Up: Packages

2.1.1 Package for basic features
--------------------------------

The package for basic features such as customizable source location
construction is named eclector.base.  Although this package does not
shadow any symbol in the common-lisp package, we still recommend the use
of explicit package prefixes to refer to symbols in this package.


File: eclector.info,  Node: Package for ordinary reader features,  Next: Package for readtable features,  Prev: Package for basic features,  Up: Packages

2.1.2 Package for ordinary reader features
------------------------------------------

The package for ordinary reader features is named eclector.reader.  To
use features of this package, we recommend the use of explicit package
prefixes, simply because this package shadows and exports names that are
also exported from the common-lisp package.  Importing this package will
likely cause conflicts with the common-lisp package otherwise.


File: eclector.info,  Node: Package for readtable features,  Next: Package for parse result construction features,  Prev: Package for ordinary reader features,  Up: Packages

2.1.3 Package for readtable features
------------------------------------

The package for readtable-related features is named eclector.readtable.
To use features of this package, we recommend the use of explicit
package prefixes, simply because this package shadows and exports names
that are also exported from the common-lisp package.  Importing this
package will likely cause conflicts with the common-lisp package
otherwise.


File: eclector.info,  Node: Package for parse result construction features,  Next: Package for CST features,  Prev: Package for readtable features,  Up: Packages

2.1.4 Package for parse result construction features
----------------------------------------------------

The package for features related to the creation of client-defined parse
results is named eclector.parse-result.  To use features of this
package, we recommend the use of explicit package prefixes, simply
because this package shadows and exports names that are also exported
from the common-lisp package.  Importing this package will likely cause
conflicts with the common-lisp package otherwise.


File: eclector.info,  Node: Package for CST features,  Prev: Package for parse result construction features,  Up: Packages

2.1.5 Package for CST features
------------------------------

The package for features related to the creation of concrete syntax
trees is named eclector.concrete-syntax-tree.  To use features of this
package, we recommend the use of explicit package prefixes, simply
because this package shadows and exports names that are also exported
from the common-lisp package.  Importing this package will likely cause
conflicts with the common-lisp package otherwise.


File: eclector.info,  Node: Basic features,  Next: Ordinary reader features,  Prev: Packages,  Up: External protocols

2.2 Basic features
==================

In this section, symbols written without package marker are in the
eclector.base package (*note Package for basic features::).

   This package provides the mechanism that enables clients to customize
the behavior of the reader.  Furthermore this package provides a
protocol for customizing a particular aspect of the behavior, namely the
construction of source positions and source ranges.  Eclector uses
source positions and source ranges in signaled conditions and parse
results (*note Parse result construction features::).

 -- Class: stream-position-condition [eclector.base]

     This condition type is the supertype of all conditions which are
     signaled by Eclector functions.  An instance of this condition type
     stores an approximate position in an input stream and an offset
     from that position.  The condition is associated with the stream
     content at the designated position and offset.  The position uses a
     representation which is controlled by the respective client by
     adding a method on the source-position generic function.  The
     offset indicates a distance in characters which must be added to
     the approximate position to produce the exact position.

 -- Generic Function: stream-position [eclector.base] condition

     This generic function can be called by clients in order to obtain
     the approximate position in the input stream to which CONDITION
     pertains.  The type and interpretation of the returned object
     depend on the client, namely the presence of client-specific
     methods on the source-position generic function.

     Applicable methods exist for all conditions of type
     stream-position-condition.

 -- Generic Function: position-offset [eclector.base] condition

     This generic function is called in order to compute the exact
     position in the input stream to which CONDITION pertains by
     refining the approximate position obtained by calling
     stream-position.  The returned value is an integer (possibly
     negative) which indicates the offset in characters from the
     approximate position to the exact position.  Since the
     representation of the approximate position is chosen by the client,
     applying the offset to that position in a suitable way is also the
     responsibility of the client.

     Applicable methods exist for all conditions of type
     stream-position-condition.

 -- Variable: *client* [eclector.base]

     This variable is used by several generic functions which are called
     by eclector.reader:read.  The default value of the variable is nil.
     Clients that want to override or extend the default behavior of
     some generic function of Eclector should bind this variable to some
     standard object and provide a method on that generic function,
     specialized to the class of that standard object.

 -- Generic Function: source-position [eclector.base] client stream

     This generic function is called in order to determine the current
     position in STREAM.  Eclector does not inspect or manipulate the
     objects returned by this generic function beyond storing them in
     signaled conditions and passing them as arguments to the
     make-source-range generic function.  A client is therefore free to
     define methods on this generic function that return arbitrary
     objects.

     The default method on this generic function calls cl:file-position.

 -- Generic Function: make-source-range [eclector.base] client start end

     This generic function is called in order to turn the source
     positions START and END into a range representation suitable for
     CLIENT.  The returned representation designates the range of input
     characters from and including the character at position START to
     but not including the character at position END.  The default
     method returns ‘(cons START END)’.


File: eclector.info,  Node: Ordinary reader features,  Next: Readtable features,  Prev: Basic features,  Up: External protocols

2.3 Ordinary reader features
============================

In this section, symbols written without package marker are in the
eclector.reader package (*note Package for ordinary reader features::)

   The features provided in this package fall into two categories:
   • The functions read, read-preserving-whitespace, read-from-string
     and read-delimited-list which, together with standard special
     variables, replicate the interface of the standard Common Lisp
     reader (except functions related to readtables which Eclector
     provides separately, *note Readtable features::).  These functions
     are discussed in the section *note Common Lisp reader compatible
     interface::.

   • The second category is comprised of the eclector.base:*client*
     special variable and a collection of protocols which allow
     customizing the behavior of the reader by defining methods
     specialized to a particular client on the generic functions of the
     protocols.

              [image src="read-call-sequence-ordinary.png" ]


Figure 2.1: Functions and typical function call sequences.  Solid arrows
represent calls, dashed arrows represent returns from function calls.
Labels above arrows represent arguments and return values.

   *note Figure 2.1: fig:read-call-sequence-ordinary. illustrates the
categorization into the Common Lisp reader compatible interface and the
extensible behavior protocol as well as typical function call patterns
that arise when the functions read, read-preserving-whitespace,
read-from-string and read-delimited-list are called by client code.

* Menu:

* Common Lisp reader compatible interface::
* Reader behavior protocol::
* Labeled objects and references::
* S-expression creation and quasiquotation::
* Readtable initialization::


File: eclector.info,  Node: Common Lisp reader compatible interface,  Next: Reader behavior protocol,  Up: Ordinary reader features

2.3.1 Common Lisp reader compatible interface
---------------------------------------------

The following functions are like their standarad Common Lisp
counterparts with the two differences that their names are symbols in
the eclector.reader package and that their behavior can deviate from
that of the standard reader depending on the value of the
eclector.base:*client* variable.

 -- Function: read [eclector.reader] &optional (input-stream
          *standard-input*) (eof-error-p t) (eof-value nil) (recursive-p
          nil)

     This function is the main entry point for the ordinary reader.  It
     is entirely compatible with the standard Common Lisp function with
     the same name.

 -- Function: read-preserving-whitespace [eclector.reader] &optional
          (input-stream *standard-input*) (eof-error-p t) (eof-value
          nil) (recursive-p nil)

     This function is entirely compatible with the standard Common Lisp
     function with the same name.

 -- Function: read-from-string [eclector.reader] string &optional
          (eof-error-p t) (eof-value nil) &key (start 0) (end nil)
          (preserve-whitespace nil)

     This function is entirely compatible with the standard Common Lisp
     function with the same name.

 -- Function: read-delimited-list [eclector.reader] char &optional
          (input-stream *standard-input*) (recursive-p nil)

     This function is entirely compatible with the standard Common Lisp
     function with the same name.


File: eclector.info,  Node: Reader behavior protocol,  Next: Labeled objects and references,  Prev: Common Lisp reader compatible interface,  Up: Ordinary reader features

2.3.2 Reader behavior protocol
------------------------------

By defining methods on the generic functions of this protocol, clients
can customize the high-level behavior of the reader.

           [image src="read-call-sequence-customization.png" ]


Figure 2.2: Functions and typical function call sequences terminating on
the right hand side of the diagram at customizable generic functions
which implement aspects of the reader algorithm and standard reader
macros.  Solid arrows represent calls, dashed arrows represent returns
from function calls.  Labels above arrows represent arguments and return
values.

   *note Figure 2.2: fig:read-call-sequence-customization. illustrates
how the customizable generic functions described in this section are
called through the client interface and the implementation of the reader
algorithm.

 -- Generic Function: call-as-top-level-read [eclector.reader] client
          thunk input-stream eof-error-p eof-value preserve-whitespace-p

     This generic function is called by read if read is called with a
     false value for the RECURSIVE-P parameter.  It calls THUNK with the
     necessary context for a global read call.  THUNK should read and
     return an object without consuming any whitespace following the
     object.  If PRESERVE-WHITESPACE-P is false, this function reads up
     to one character of whitespace after THUNK returns.  This function
     returns the object or EOF-VALUE returned by THUNK as its first
     value.  It may return additional values.

     The default method on this generic function performs two tasks:
       1. It establishes a context in which labels (#N=) and references
          (#N#) work.

       2. It realizes the requested PRESERVE-WHITESPACE-P behavior.

 -- Generic Function: read-common [eclector.reader] client input-stream
          eof-error-p eof-value

     This generic function is called by read, passing it the value of
     the variable eclector.base:*client* and the corresponding
     parameters.  Client code can add methods on this function,
     specializing them to the client class of its choice.  The actions
     that read needs to take for different values of the parameter
     RECURSIVE-P have already been taken before read calls this generic
     function.

 -- Generic Function: read-maybe-nothing [eclector.reader] client
          input-stream eof-error-p eof-value

     This generic function can be called directly by the client or by
     the generic function read-common to read an object or consume input
     without returning an object.  If called directly by the client, the
     call has to be in the dynamic scope of a call-as-top-level-read
     call.  The function read-maybe-nothing either

        • encounters the end of input on INPUT-STREAM and, depending on
          EOF-ERROR-P either signals an error or returns the values
          EOF-VALUE and :eof

        • or reads one or more whitespace characters an returns the
          values nil and :whitespace

        • or reads an object.  If *read-suppress* is true, the function
          returns nil and :suppress.  Otherwise it returns the object
          and :object.

        • or consumes a macro character and the characters consumed by
          the associated reader macro function if that reader macro
          function does not return a value.  In this case the function
          returns nil and :skip.

 -- Generic Function: note-skipped-input [eclector.reader] client
          input-stream reason

     This generic function is called whenever the reader skips some
     input such as a comment or a form that must be skipped because of a
     reader conditional.  It is called with the value of the variable
     eclector.base:*client*, the input stream from which the input is
     being read and an object indicating the reason for skipping the
     input.  The default method on this generic function does nothing.
     Client code can supply a method that specializes to the client
     class of its choice.

     When this function is called, the stream is positioned immediately
     _after_ the skipped input.  Client code that wants to know both the
     beginning and the end of the skipped input must remember the stream
     position before the call to read was made as well as the stream
     position when the call to this function is made.

 -- Variable: *skip-reason* [eclector.reader]

     This variable is used by the reader to determine why a range of
     input characters has been skipped.  To this end, internal functions
     of the reader as well as reader macros can set this variable to a
     suitable value before skipping over some input.  Then, after the
     input has been skipped, the generic function note-skipped-input is
     called with the value of the variable as its REASON argument.

     As an example, the method on note-skipped-input specialized to
     eclector.parse-result:parse-result-client relays the reason and
     position information to the client by calling the
     eclector.parse-result:make-skipped-input-result generic function
     (*note Parse result construction features::).

 -- Generic Function: read-token [eclector.reader] client input-stream
          eof-error-p eof-value

     This generic function is called by read-common when it has been
     detected that a token should be read.  This function is responsible
     for accumulating the characters of the token and then calling
     interpret-token (see below) in order to create and return a token.

 -- Generic Function: interpret-token [eclector.reader] client
          input-stream token escape-ranges

     This generic function is called by read-token in order to create a
     token from accumulated token characters.  The parameter TOKEN is a
     string containing the characters that make up the token.  The
     parameter ESCAPE-RANGES indicates ranges of characters read from
     INPUT-STREAM and preceded by a character with single-escape syntax
     or delimited by characters with multiple-escape syntax.  Values of
     ESCAPE-RANGES are lists of elements of the form (START\ .\ END)
     where START is the index of the first escaped character and END is
     the index _following_ the last escaped character.  Note that START
     and VAR can be identical indicating no escaped characters.  This
     can happen in cases like a||b.  The information conveyed by the
     ESCAPE-RANGES parameter is used to convert the characters in TOKEN
     according to the _readtable case_ of the current readtable before a
     token is constructed.

 -- Generic Function: check-symbol-token [eclector.reader] client
          input-stream token escape-ranges position-package-marker-1
          position-package-marker-2

     This generic function is called by the default method on
     interpret-token when the syntax of the token corresponds to that of
     a symbol.  This function checks the syntactic validity of the
     symbol token and signals an error in case of a syntax error.  If
     there are no syntax errors (or error recovery has been performed,
     *note Recovering from errors::), this function returns three
     values:
       1. TOKEN or a value derived from TOKEN by error recovery
          operations.

       2. POSITION-PACKAGE-MARKER-1 or a value derived from
          POSITION-PACKAGE-MARKER-1 by error recovery operations.

       3. POSITION-PACKAGE-MARKER-2 or a value derived from
          POSITION-PACKAGE-MARKER-2 by error recovery operations.

     The parameter INPUT-STREAM is the input stream from which the
     characters were read.  The parameter TOKEN is a string that
     contains all the characters of the token.  The parameter
     ESCAPE-RANGES indicates ranges within TOKEN that were preceded by a
     character with single-escape syntax or delimited by characters with
     multiple-escape syntax.  The parameter POSITION-PACKAGE-MARKER-1
     contains the index into TOKEN of the first package marker, or nil
     if the token contains no package markers.  The parameter
     POSITION-PACKAGE-MARKER-2 contains the index into TOKEN of the
     second package marker, or nil if the token contains no package
     markers or only a single package marker.

     The default method on this generic function checks the positions of
     the package markers taking into account escape ranges.  The method
     signals errors and allows error recovery as described above.

 -- Generic Function: interpret-symbol-token [eclector.reader] client
          input-stream token position-package-marker-1
          position-package-marker-2

     This generic function is called by the default method on
     interpret-token when the syntax of the token corresponds to that of
     a valid symbol.  The parameter INPUT-STREAM is the input stream
     from which the characters were read.  The parameter TOKEN is a
     string that contains all the characters of the token.  The
     parameter POSITION-PACKAGE-MARKER-1 contains the index into TOKEN
     of the first package marker, or nil if the token contains no
     package markers.  The parameter POSITION-PACKAGE-MARKER-2 contains
     the index into TOKEN of the second package marker, or nil if the
     token contains no package markers or only a single package marker.

     The default method on this generic function calls interpret-symbol
     (see below) with a symbol name string and a package indicator.

 -- Generic Function: interpret-symbol [eclector.reader] client
          input-stream package-indicator symbol-name internp

     This generic function is called by the default method on
     interpret-symbol-token as well as the default #: reader macro
     function to resolve a symbol name string and a package indicator to
     a representation of the designated symbol.  The parameter
     INPUT-STREAM is the input stream from which PACKAGE-INDICATOR and
     SYMBOL-NAME were read.  The parameter PACKAGE-INDICATOR is a either

        • a string designating the package of that name

        • the keyword :current designating the current package

        • the keyword :keyword designating the keyword package

        • nil to indicate that an uninterned symbol should be created

     The SYMBOL-NAME is the name of the desired symbol.

     The default method uses cl:find-package (or cl:*package* when
     PACKAGE-INDICATOR is :current) to resolve PACKAGE-INDICATOR
     followed by cl:find-symbol or cl:intern, depending on INTERNP, to
     resolve SYMBOL-NAME.

     A second method which is specialized on PACKAGE-INDICATOR being nil
     uses cl:make-symbol to create uninterned symbols.

 -- Generic Function: call-reader-macro [eclector.reader] client
          input-stream char readtable

     This generic function is called when the reader has determined that
     some character is associated with a reader macro.  The parameter
     CHAR has to be used in conjunction with the READTABLE parameter to
     obtain the macro function that is associated with the macro
     character.  The parameter INPUT-STREAM is the input stream from
     which the reader macro function will read additional input to
     accomplish its task.

     The default method on this generic function simply obtains the
     reader macro function for CHAR from READTABLE and calls it, passing
     INPUT-STREAM and CHAR as arguments.  The default method therefore
     does the same thing that the standard Common Lisp reader does.

 -- Generic Function: find-character [eclector.reader] client designator

     This generic function is called by the default #\ reader macro
     function to find a character.  DESIGNATOR is either
        • a string that is the name of the character to be found with
          single and multiple escapes removed, but with the case of all
          characters as it was in the input.

        • or a character designating itself.
     The function has to either return the character designated by
     DESIGNATOR or nil if no such character exists.

     If DESIGNATOR is a string, it is the responsibility of the client
     to disregard the case of characters in DESIGNATOR, for example by
     producing an uppercase string from DESIGNATOR before looking up the
     designated character.

     A default method on this generic function that is not specialized
     to any particular client but is specialized to DESIGNATOR being a
     string recognizes the mandatory character names listing in
     HyperSpec Section 13.1.7 Character Names.  Another default method
     on this generic function that is not specialized to any particular
     client but is specialized to DESIGNATOR being a character just
     returns DESIGNATOR.

 -- Generic Function: make-structure-instance [eclector.reader] client
          name initargs

     This generic function is called by the default #S reader macro
     function to construct structure instances.  NAME is a symbol naming
     the structure type of which an instance should be constructed.
     INITARGS is a list the elements of which alternate between string
     designators naming structure slots and values for those slots.

     It is the responsibility of the client to coerce the string
     designators to symbols as if by ‘(intern (string slot-name)
     (find-package 'keyword))’ as described in the Common Lisp
     specification.

     There is no default method on this generic function since there is
     no portable way to construct structure instances given only the
     name of the structure type.

 -- Generic Function: call-with-current-package [eclector.reader] client
          thunk package-designator

     This generic function is called by the reader when input has to be
     read with a particular current package.  This is currently only the
     case in the #+ and #- reader macro functions which read feature
     expressions in the keyword package.  THUNK is a function that
     should be called without arguments.  PACKAGE-DESIGNATOR designates
     the package that should be the current package around the call to
     THUNK.

     The default method on this generic function simply binds
     cl:*package* to the result of ‘(cl:find-package
     PACKAGE-DESIGNATOR)’ around calling THUNK.

 -- Generic Function: evaluate-expression [eclector.reader] client
          expression

     This generic function is called by the default #. reader macro
     function to perform read-time evaluation.  EXPRESSION is the
     expression that should be evaluated as it was returned by a
     recursive read call and potentially influenced by CLIENT.  The
     function has to either return the result of evaluating EXPRESSION
     or signal an error.

     The default method on this generic function simply returns the
     result of ‘(cl:eval EXPRESSION)’.

 -- Generic Function: check-feature-expression [eclector.reader] client
          feature-expression

     This generic function is called by the default #+ and #- reader
     macro functions to check the well-formedness of FEATURE-EXPRESSION
     which has been read from the input stream before evaluating it.
     For compound expressions, only the outermost expression is checked
     regarding the atom in operator position and its shape – child
     expressions are not checked.  The function returns an unspecified
     value if FEATURE-EXPRESSION is well-formed and signals an error
     otherwise.

     The default method on this generic function accepts standard Common
     Lisp feature expression, i.e.  expressions recursively composed of
     symbols, :not-expressions, :and-expressions and :or-expressions.

 -- Generic Function: evaluate-feature-expression [eclector.reader]
          client feature-expression

     This generic function is called by the default #+ and #- reader
     macro functions to evaluate FEATURE-EXPRESSION which has been read
     from the input stream.  The function returns either true or false
     if FEATURE-EXPRESSION is well-formed and signals an error
     otherwise.

     For compound feature expressions, the well-formedness of child
     expressions is not checked immediately but lazily, just before the
     child expression in question is evaluated in a subsequent
     evaluate-feature-expression call.  This allows expressions like
     ‘#+(and my-cl-implementation (special-feature a b)) FORM’ to be
     read without error when the :my-cl-implementation feature is
     absent.

     The default method on this generic function first calls
     check-feature-expression to check the well-formedness of
     FEATURE-EXPRESSION.  It then evaluates FEATURE-EXPRESSION according
     to standard Common Lisp semantics for feature expressions.


File: eclector.info,  Node: Labeled objects and references,  Next: S-expression creation and quasiquotation,  Prev: Reader behavior protocol,  Up: Ordinary reader features

2.3.3 Labeled objects and references
------------------------------------

Eclector includes implementations of the #= and ## reader macros and
they are present in the default readtable.  One way to customize the
behavior of the reader around the #= and ## syntax is replacing the
reader macro functions with custom ones but with this approach the
client code has to reimplement a lot of functionality.  As a finer
grained and more composable mechanism for customization, Eclector
provides a protocol for implementing and customizing the behavior of the
#= and ## reader macros, with or without modifying the readtable.  The
remainder of this section describes that protocol.

   To start with a bit of terminology, we call the object created by
reading #N=EXPRESSION a “labeled object”.  We call N the “label” of the
labeled object and the result of reading EXPRESSION the “object” of the
labeled object.  We say that #N=EXPRESSION “defines” the labeled object
and #N# “references” the labeled object.  We call the reference
“circular” if #N# occurs within EXPRESSION.  Labeled objects are
internal to the reader and only exist during eclector.reader:read calls:
before such a call returns an object, each labeled object within the
returned object is replaced by its respective final object.  Callers of
eclector.reader:read and related functions will therefore only ever see
the object, never the labeled object(1).

   On a technical level, a labeled object is represented as a data type
with a current state and a single (possibly unbound) slot containing the
object.  The following diagrams depicts the possible states of a labeled
object together with input patterns and corresponding transitions:

                 [image src="labeled-object-states.png" ]


Figure 2.3: Possible states of a labeled object and input patterns which
correspond to state transitions.

   Put differently, a labeled object can be in the following states:

State                                Object slot
------------------------------------------------------------
undefined                            –
defined                              unbound
final                                the object
referenced _(not strictly needed)_   the object
circular                             unbound
final (circular)                     the object
referenced (circular) _(not          the object
strictly needed)_

   The distinction between the states final and referenced on the one
hand and final (circular), and referenced (circular) on the other hand
is not required for implementing labeled objects.  Those two pairs of
states are therefore collapsed to just final and final (circular) in the
remainder of this section.  The following figure and paragraphs describe
generic functions and methods which implement the creation,
registration, lookup and manipulation of labeled objects according to
the reduced set of states:

               [image src="labeled-object-api-states.png" ]


Figure 2.4: Reduced set of states of a labeled object and protocol
functions with corresponding state transitions.

   In addition to the generic functions referenced in the above diagram,
the generic functions fixup-graph-p, fixup-graph and fixup are part of
the protocol.  Those functions are used to replace labeled objects with
their respective final objects within an object that is about to be
returned to the caller of eclector.reader:read (2).  To this end, the #=
reader macro function must inspect and update the state of the labeled
object it is processing after reading EXPRESSION by calling
finalize-labeled-object.  finalize-labeled-object decides whether
fixup-graph (see below) must be called: If after reading EXPRESSION the
labeled object is in state :circular, EXPRESSION must have contained
circular references and the result of reading it contains labeled
objects that have to be replaced with their respective final objects.
fixup-graph and fixup perform this replacement.  This replacement is
performed by recursively traversing objects which are reachable from the
final object of the labeled objects, for example by visiting the slots
of standard objects, and replacing labeled objects with their respective
final object.

   In certain cases, the computational complexity of this traversal and
replacement can be rather high, depending on when and how exactly the
traversal is performed: consider an expression of the form #1=(1 #1#
#2=(2 #2# ...)).  The nested labeled objects in this expression are all
circular and thus require fixing up.  The read call for the innermost
labeled object, say #100=..., returns first and the fixup processing for
the labeled object could be performed immediately.  The problem is that
each of the labeled objects would be processed in the same manner which
would lead to a computation complexity of O(N M) where N is the number
of labels and M is the number of nodes in the object graph rooted at the
object which is returned by the outermost read call.  One way to avoid
this problem would be to perform fixup processing only for the outermost
read call.  The problem with that approach is that only a small
sub-graph of the whole object graph may be circular in which case most
of the work for traversing the whole graph would be wasted.  To address
both problems, Eclector allows clients to track the nesting of labeled
objects and fix up sub-graphs which contain multiple nested objects in
one go (*note fixup-graph-p: Generic-Function
eclector.reader|fixup-graph-p.).

 -- Generic Function: call-with-label-tracking [eclector.reader] client
          thunk

     This generic function is called by the default method on
     call-as-top-level-read in order to establish a context for tracking
     #= label definitions and ## label references around a call to
     THUNK.

     The default method on this generic function establishes a context
     in which the default #= and ## reader macro functions can make the
     appropriate calls to note-labeled-object, forget-labeled-object,
     find-labeled-object.

 -- Generic Function: note-labeled-object [eclector.reader] client
          input-stream label parent

     This generic function is called by the default #= reader macro
     function to note the definition of a labeled object with label
     LABEL while reading from INPUT-STREAM.  The function creates,
     registers and returns a representation of the labeled object.  The
     returned object is registered in the sense that a subsequent call
     to find-labeled-object with arguments CLIENT and LABEL returns the
     same object unless forget-labeled-object has been called to
     unregister the object.

     PARENT is either nil or a (previously created) surrounding labeled
     object.  The parent labeled object is provided to allow the client
     to potentially defer fixup processing for the new labeled object if
     the processing for the surrounding labeled object subsumes the
     processing for the new labeled object.

     Note that, when reading an expression of the form #N=OBJECT, this
     function is called after reading #N= from INPUT-STREAM but before
     reading OBJECT.  Consequently, the created and returned labeled
     object is defined but does not have an object associated with it.

     The default method on this generic function calls
     make-labeled-object with CLIENT, INPUT-STREAM and LABEL to create
     an object of an unspecified type.  The method registers and returns
     the created object.  Client code should manipulate the object only
     via the generic functions described in this section and in
     particular not rely on the object being of a particular type (since
     methods on make-labeled-object specialized to certain client
     classes could return unexpected objects).  The default method
     requires the context established by the default method on
     call-with-label-tracking.

 -- Generic Function: forget-labeled-object [eclector.reader] client
          label

     This generic function is called by the default #= reader macro
     function when Eclector reads an invalid labeled object of the form
     #N=#N# and the caller chooses to recover from the resulting error
     (*note Recovering from errors::).  In that situation, the remainder
     of the input is processed as if there had been no labeled object
     with label N.  This function makes the labeled object undefined so
     that a subsequent find-labeled-object call for LABEL will return
     nil.

     The default method on this generic function requires the context
     established by the default method on call-with-label-tracking.

 -- Generic Function: find-labeled-object [eclector.reader] client label

     This generic function is called by the default ## reader macro
     function to look up the previously registered representation of a
     labeled object for LABEL.  The function returns nil if no such
     object has been registered for LABEL and the registered object
     otherwise.

     The default method on this generic function requires the context
     established by the default method on call-with-label-tracking.

 -- Generic Function: make-labeled-object [eclector.reader] client
          input-stream label parent

     This generic function is called by note-labeled-object to create
     and return a representation of a labeled object with label LABEL.
     PARENT is either nil or a previously created, surrounding labeled
     object which allows the client to potentially defer fixup
     processing for the new labeled object if the processing for the
     surrounding labeled object subsumes the processing.

     The default method on this generic function creates and returns an
     object of an unspecified type.  Client code should manipulate the
     object only via the generic functions labeled-object-state,
     finalize-labeled-object and reference-labeled-object and in
     particular not rely on the object being of a particular type (since
     methods on this generic function specialized to certain client
     classes could return unexpected objects).

 -- Generic Function: labeled-object-state [eclector.reader] client
          object

     This generic function is called by the default #= reader macro
     function to determine the state of OBJECT.  This function returns

        • nil if OBJECT is not a labeled object

        • two values if OBJECT is a labeled object: one of the keywords
          :defined, :circular, :final, :final/circular and the final
          object stored in OBJECT if the first value is either :final or
          :final/circular or nil otherwise.

     The following table lists all possible return value shapes:
     OBJECT is a labeled    First value            Second value
     object
     ---------------------------------------------------------------------
     no                     nil
     yes                    :defined               nil
     yes                    :circular              nil
     yes                    :final                 FINAL-OBJECT
     yes                    :final/circular        FINAL-OBJECT

     The default method on this generic function is applicable to
     labeled object representations returned by the default methods on
     note-labeled-object and make-labeled-object.

 -- Generic Function: finalize-labeled-object [eclector.reader] client
          labeled-object object

     This generic function is called by the default #= reader macro
     function after reading a complete labeled object in order to store
     OBJECT in LABELED-OBJECT and change the state of LABELED-OBJECT to
     either :final or :final/circular.  The function returns two values:
     the finalized LABELED-OBJECT and the new state of LABELED-OBJECT.

     The default method on this generic function is applicable to
     labeled object representations returned by the default methods on
     note-labeled-object and make-labeled-object.

 -- Generic Function: reference-labeled-object [eclector.reader] client
          input-stream labeled-object

     This generic function is called by the default ## reader macro
     function to process a reference to LABELED-OBJECT while reading
     from INPUT-STREAM.  LABELED-OBJECT must be a representation of a
     labeled object and has, in the context of the ## reader macro
     function, likely been obtained by calling find-labeled-object.
     Depending on the state of LABELED-OBJECT, this function returns
     either LABELED-OBJECT itself or an object that can be returned to
     the caller as-is.  In case LABELED-OBJECT is returned, it will be
     replaced by its associated object later, when fixup-graph is
     called.

     The default method on this generic function is applicable to
     labeled object representations returned by the default methods on
     note-labeled-object and make-labeled-object.

   As briefly mentioned above, the generic functions fixup-graph and
fixup traverse and inspect objects in the object graph reachable from an
object that is about to be returned to the caller of
eclector.reader:read.  In order to distinguish ordinary objects from
labeled objects that act as placeholders in the object graph and must be
replaced with their respective final objects, fixup methods call
labeled-object-state on all encountered objects.  labeled-object-state
returns nil for all objects that are not labeled objects and :final for
labeled objects which must be replaced with their final object.

 -- Generic Function: fixup-graph-p [eclector.reader] client
          root-labeled-object

     This generic function is potentially called by a method on
     finalize-labeled-object to determine whether the object graph
     reachable from the object of ROOT-LABELED-OBJECT should be fixed up
     by calling fixup-graph with CLIENT and LABELED-OBJECT.

     Multiple default methods on this generic function jointly implement
     the following behavior:

        • If ROOT-LABELED-OBJECT has a parent labeled object,
          ROOT-LABELED-OBJECT should not be fixup up immediately (since
          the fixup processing for ancestor labeled objects will subsume
          the fixup processing for ROOT-LABELED-OBJECT).

        • If ROOT-LABELED-OBJECT does not have parent labeled object but
          has child labeled objects, ROOT-LABELED-OBJECT should be fixed
          up immediately.

        • If ROOT-LABELED-OBJECT does not have parent labeled object and
          is in state :final/circular, ROOT-LABELED-OBJECT should be
          fixed up immediately.

 -- Generic Function: fixup-graph [eclector.reader] client
          root-labeled-object &key object-key

     This generic function is potentially called after the reader has
     constructed an object graph which is reachable from the object of
     ROOT-LABELED-OBJECT and noticed circular references within this
     graph to fix up circular references before the object of
     ROOT-LABELED-OBJECT is returned to the caller (of read or related
     functions).

     OBJECT-KEY is a function that accepts a labeled object and returns
     the object of the labeled object.

     The default method on this generic function creates a hash table
     for tracking already processed objects and calls fixup with CLIENT,
     the object of ROOT-LABELED-OBJECT and the hash table to recursively
     process objects in the object graph which is reachable from the
     object of ROOT-LABELED-OBJECT.

 -- Generic Function: fixup [eclector.reader] client object seen-objects

     This generic function is potentially called to apply
     circularity-related changes to the object constructed by the reader
     before it is returned to the caller.  OBJECT is the object that
     should be modified.  SEEN-OBJECTS is a eq-hash table used to track
     already processed objects (see below).  A method specialized to a
     class, instances of which consists of parts, should modify OBJECT
     by scanning its parts for labeled object markers, replacing found
     labeled object markers with the respective final object and
     recursively calling fixup for all parts.

     To recognize labeled objects which have to be replaced, methods
     should call labeled-object-state on each part of OBJECT and
     interpret the returned values as follows: if nil is returned, the
     part should not be replaced but recursively processed.  If :final
     is returned as the first value, the part should be replaced with
     the final object that is returned as the second value.  Parts are
     replaced by mutating OBJECT.

     fixup is called for side effects – its return value is ignored.

     Default methods specializing the OBJECT parameter to cons, array,
     standard-object and hash-table process instances of those classes
     in the obvious way.

     An unspecialized :around method queries and updates SEEN-OBJECTS to
     ensure that each object is processed exactly once.

   ---------- Footnotes ----------

   (1) Reader macro functions which call eclector.reader:read may
receive labeled objects under certain circumstances (*note Circular
objects and custom reader macros::).

   (2) This fixup processing has to be delayed under certain
circumstances (*note Circular objects and custom reader macros::).


File: eclector.info,  Node: S-expression creation and quasiquotation,  Next: Readtable initialization,  Prev: Labeled objects and references,  Up: Ordinary reader features

2.3.4 S-expression creation and quasiquotation
----------------------------------------------

The following generic functions allow clients to construct
representations of quoted and quasiquoted forms.

 -- Generic Function: wrap-in-quote [eclector.reader] client material

     This generic function is called by the default '-reader macro
     function to construct a quotation form in which MATERIAL is the
     quoted material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'common-lisp:quote MATERIAL)’.

 -- Generic Function: wrap-in-quasiquote [eclector.reader] client form

     This generic function is called by the default `-reader macro
     function to construct a quasiquotation form in which FORM is the
     quasiquoted material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'eclector.reader:quasiquote FORM)’.

 -- Generic Function: wrap-in-unquote [eclector.reader] client form

     This generic function is called by the default ,-reader macro
     function to construct an unquote form in which FORM is the unquoted
     material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'eclector.reader:unquote FORM)’.

 -- Generic Function: wrap-in-unquote-splicing [eclector.reader] client
          form

     This generic function is called by the default ,@-reader macro
     function to construct a splicing unquote form in which FORM is the
     unquoted material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'eclector.reader:unquote-splicing FORM)’.

   Backquote and unquote syntax is forbidden in some contexts such as
multi-dimensional array literals (#A) and structure literals (#S) thus
Eclector has a mechanism for controlling whether backquote, unquote or
both should be allowed in a given context.  Since custom reader macros
may also have to control this aspect, Eclector provides an external
protocol:

 -- Macro: with-forbidden-quasiquotation [eclector.reader] context
          &optional (quasiquote-forbidden-p t) (unquote-forbidden-p t)
          &body body

     Disallow backquote syntax, unquote syntax or both in read functions
     called during the execution of BODY.  CONTEXT is a symbol
     identifying the current context which is used for error reporting.
     A typical value is the name of the reader macro function in which
     this macro is used.  QUASIQUOTE-FORBIDDEN-P controls whether
     backquote syntax should be forbidden.  The value :keep causes the
     binding to remain unchanged.  UNQUOTE-FORBIDDEN-P controls whether
     unquote syntax should be forbidden.  The value :keep causes the
     binding to remain unchanged.

 -- Generic Function: wrap-in-function [eclector.reader] client name

     This generic function is called by the default #'-reader macro
     function to construct a form that applies the function special
     operator to the NAME expression.

     The default method on this generic function returns a result
     equivalent to ‘(list 'common-lisp:function FORM)’.


File: eclector.info,  Node: Readtable initialization,  Prev: S-expression creation and quasiquotation,  Up: Ordinary reader features

2.3.5 Readtable initialization
------------------------------

The standard syntax types and macro character associations used by the
ordinary reader can be set up for any readtable object implementing the
readtable protocol (*note Readtable features::).  The following
functions are provided for this purpose:

 -- Function: set-standard-syntax-types [eclector.reader] readtable

     This function sets the standard syntax types in READTABLE (See
     HyperSpec section 2.1.4.)

 -- Function: set-standard-macro-characters [eclector.reader] readtable

     This function sets the standard macro characters in READTABLE (See
     HyperSpec section 2.4.)

 -- Function: set-standard-dispatch-macro-characters [eclector.reader]
          readtable

     This function sets the standard dispatch macro characters, that is
     sharpsign and its sub-characters, in READTABLE (See HyperSpec
     section 2.4.8.)

 -- Function: set-standard-syntax-and-macros [eclector.reader] readtable

     This function sets the standard syntax types and macro characters
     in READTABLE by calling the above three functions.


File: eclector.info,  Node: Readtable features,  Next: Parse result construction features,  Prev: Ordinary reader features,  Up: External protocols

2.4 Readtable features
======================

In this section, symbols written without package marker are in the
eclector.readtable package (*note Package for readtable features::).

   This package exports two kinds of symbols:

  1. Symbols the names of which correspond to the names of symbols in
     the common-lisp package.  The functions bound to these symbols are
     generic versions of the corresponding standard Common Lisp
     functions.  Clients can define custom readtables by defining
     methods on these generic functions.

  2. Symbols bound to additional functions and condition types.

 -- Generic Function: readtablep [eclector.readtable] object

     This function is the generic version of the standard Common Lisp
     function cl:readtablep.  The function returns true if OBJECT can be
     used as a readtable in Eclector via the protocol functions in the
     ecelctor.readtable package.  The default method returns nil.

   TODO


File: eclector.info,  Node: Parse result construction features,  Next: CST reader features,  Prev: Readtable features,  Up: External protocols

2.5 Parse result construction features
======================================

In this section, symbols written without package marker are in the
eclector.parse-result package (*note Package for parse result
construction features::).

   This package provides clients with a reader that behaves similarly to
cl:read but returns custom parse result objects controlled by the
client.  Some parse results correspond to things like symbols, numbers
and lists that cl:read would return, while others, if the client
chooses, represent comments and other kinds of input that cl:read would
discard.  Furthermore, clients can associate source location information
with parse results.

   Clients using this package pass a “client” instance for which methods
on the generic functions described below are applicable to read,
read-preserving-whitespace or read-from-string.  Suitable client classes
can be constructed by using parse-result-client as a superclass and at
least defining a method on the generic function make-expression-result.

            [image src="read-call-sequence-parse-result.png" ]


Figure 2.5: Functions and typical function call sequences.  Solid arrows
represent calls, dashed arrows represent returns from function calls.
Labels above arrows represent arguments and return values.  Differences
from the non-parse result version are highlighted with bold text.

   *note Figure 2.5: fig:read-call-sequence-parse-result. shows typical
function call patterns that arise when the functions read,
read-preserving-whitespace, read-from-string and read-delimited-list are
called by client code.

 -- Function: read [eclector.parse-result] client &optional
          (input-stream *standard-input*) (eof-error-p t) (eof-value
          nil)

     This function is the main entry point for this variant of the
     reader.  It is in many ways similar to the standard Common Lisp
     function cl:read.  The differences are:

        • A client instance must be supplied as the first argument.

        • The first return value, unless EOF-VALUE is returned, is an
          arbitrary parse result object created by the client, not
          generally the read object.

        • The second return value, unless EOF-VALUE is returned, is a
          list of “orphan” results.  These results are return values of
          make-skipped-input-result and arise when skipping input at the
          toplevel such as comments which are not lexically contained in
          lists: #|orphan|# (#|not orphan|#).

        • The function does not accept a RECURSIVE parameter since it
          sets up a dynamic environment in which calls to
          eclector.reader:read behave suitably.

 -- Function: read-preserving-whitespace [eclector.parse-result] client
          &optional (input-stream *standard-input*) (eof-error-p t)
          (eof-value nil)

     This function is similar to the standard Common Lisp function
     cl:read-preserving-whitespace.  The differences are the same as
     described above for read compared to cl:read.

 -- Function: read-from-string [eclector.parse-result] client string
          &optional (eof-error-p t) (eof-value nil) &key (start 0) (end
          nil) (preserve-whitespace nil)

     This function is similar to the standard Common Lisp function
     cl:read-from-string.  The differences are:

        • A client instance must be supplied as the first argument.

        • The first return value, unless EOF-VALUE is returned, is an
          arbitrary parse result object created by the client, not
          generally the read object.

        • The _third_ return value, unless EOF-VALUE is returned, is a
          list of “orphan” results (Described above).

 -- Class: parse-result-client [eclector.parse-result]

     This class should generally be used as a superclass for client
     classes using this package.

 -- Generic Function: make-expression-result [eclector.parse-result]
          client result children source

     This generic function is called in order to construct a parse
     result object.  The value of the RESULT parameter is the raw object
     read.  The value of the CHILDREN parameter is a list of already
     constructed parse result objects representing objects read by
     recursive read calls.  The value of the SOURCE parameter is a
     source range, as returned by eclector.base:make-source-range and
     eclector.base:source-position delimiting the range of characters
     from which RESULT has been read.

     This generic function does not have a default method since the
     purpose of the package is the construction of _custom_ parse
     results.  Thus, a client must define a method on this generic
     function.

 -- Generic Function: make-skipped-input-result [eclector.parse-result]
          client stream reason source

     This generic function is called after the reader skipped over a
     range of characters in STREAM.  It returns either nil if the
     skipped input should not be represented or a client-specific
     representation of the skipped input.  The value of the SOURCE
     parameter designates the skipped range using a source range
     representation obtained via make-source-range and source-position.

     Reasons for skipping input include comments, the #+ and #- reader
     macros and *read-suppress*.  The aforementioned reasons are
     reflected by the value of the REASON parameter as follows:

     Input                                Value of the REASON parameter
     --------------------------------------------------------------------------
     Comment starting with ;              (:line-comment . 1)
     Comment starting with ;;             (:line-comment . 2)
     Comment starting with n ;            (:line-comment . n)
     Comment delimited by #| |#           :block-comment
     #+_false-expression_                 (:sharpsign-plus .
                                          _false-expression_)
     #-_true-expression_                  (:sharpsign-minus .
                                          _true-expression_)
     *read-suppress* is true              *read-suppress*
     A reader macro returns no values     :reader-macro

     The default method returns nil, that is the skipped input is not
     represented as a parse result.


File: eclector.info,  Node: CST reader features,  Prev: Parse result construction features,  Up: External protocols

2.6 CST reader features
=======================

In this section, symbols written without package marker are in the
eclector.concrete-syntax-tree package (*note Package for CST
features::).

 -- Function: read [eclector.concrete-syntax-tree] &optional
          (input-stream *standard-input*) (eof-error-p t) (eof-value
          nil)

     This function is the main entry point for the CST reader.  It is
     mostly compatible with the standard Common Lisp function cl:read.
     The differences are:

        • The return value, unless EOF-VALUE is returned, is an instance
          of a subclass of concrete-syntax-tree:cst.

        • The function does not accept a RECURSIVE parameter since it
          sets up a dynamic environment in which calls to
          eclector.reader:read behave suitably.

 -- Function: read-preserving-whitespace [eclector.concrete-syntax-tree]
          &optional (input-stream *standard-input*) (eof-error-p t)
          (eof-value nil)

     This function is similar to the standard Common Lisp function
     cl:read-preserving-whitespace.  The differences are the same as
     described above for read compared to cl:read.

 -- Function: read-from-string [eclector.concrete-syntax-tree] string
          &optional (eof-error-p t) (eof-value nil) &key (start 0) (end
          nil) (preserve-whitespace nil)

     This function is similar to the standard Common Lisp function
     cl:read-from-string.  The differences are the same as described
     above for read compared to cl:read.


File: eclector.info,  Node: Recovering from errors,  Next: Side effects,  Prev: External protocols,  Up: Top

3 Recovering from errors
************************

* Menu:

* Error recovery features::
* Recoverable errors::
* Potential problems::


File: eclector.info,  Node: Error recovery features,  Next: Recoverable errors,  Up: Recovering from errors

3.1 Error recovery features
===========================

Eclector offers extensive support for recovering from many syntax
errors, continuing to read from the input stream and return a result
that somewhat resembles what would have been returned in case the syntax
had been valid.  To this end, a restart named eclector.reader:recover is
established when recoverable errors are signaled.  Like the standard
Common Lisp restart cl:continue, this restart can be invoked by a
function of the same name:

 -- Function: recover [eclector.reader] &optional condition

     This function recovers from an error by invoking the most recently
     established applicable restart named eclector.reader:recover.  If
     no such restart is currently established, it returns nil.  If
     CONDITION is non-nil, only restarts that are either explicitly
     associated with CONDITION, or not associated with any condition are
     considered.

   When a read call during which error recovery has been performed
returns, Eclector tries to return an object that is similar in terms of
type, numeric value, sequence length, etc.  to what would have been
returned in case the input had been well-formed.  For example,
recovering after encountering the invalid digit in #b11311 returns
either the number #b11011 or the number #b11111.


File: eclector.info,  Node: Recoverable errors,  Next: Potential problems,  Prev: Error recovery features,  Up: Recovering from errors

3.2 Recoverable errors
======================

A syntax error and a corresponding recovery strategy are characterized
by the type of the signaled condition and the report of the established
eclector.reader:recover restart respectively.  Attempting to list and
describe all examples of both would provide little insight.  Instead,
this section describes different classes of errors and corresponding
recovery strategies in broad terms:

   • Replace a missing numeric macro parameter or ignore an invalid
     numeric macro parameter.  Examples: #=1 ⟶ 1, #5P"." ⟶ #P"."

   • Add a missing closing delimiter.  Examples: "foo ⟶ "foo", (1 2 ⟶ (1
     2), #(1 2 ⟶ #(1 2), #C(1 2 ⟶ #C(1 2)

   • Replace an invalid digit or an invalid number with a valid one.
     This includes digits which are invalid for a given base but also
     things like 0 denominator.  Examples: #12rc ⟶ 1, 1/0 ⟶ 1, #C(1
     :foo) ⟶ #C(1 1)

   • Replace an invalid character with a valid one.  Example: #\foo ⟶
     #\?

   • Invalid constructs can sometimes be ignored.  Examples: (,1) ⟶ (1),
     #S(foo :bar 1 2 3) ⟶ #S(foo :bar 1)

   • Excess parts can often be ignored.  Examples: #C(1 2 3) ⟶ #C(1 2),
     #2(1 2 3) ⟶ #2(1 2)

   • Replace an entire construct by some fallback value.  Example: #S(5)
     ⟶ nil, (#1=) ⟶ (nil)


File: eclector.info,  Node: Potential problems,  Prev: Recoverable errors,  Up: Recovering from errors

3.3 Potential problems
======================

Note that attempting to recover from syntax errors may lead to apparent
success in the sense that the read call returns an object, but this
object may not be what the caller wanted.  For example, recovering from
the missing closing " in the following example

     (defun foo (x y)
       "My documentation string
       (+ x y))

   results in ‘(DEFUN FOO (X Y) "My documentation string<newline> (+ x
y))")’, not ‘(DEFUN FOO (X Y) "My documentation string" (+ x y))’.


File: eclector.info,  Node: Side effects,  Next: Interpretation of unclear parts of the specification,  Prev: Recovering from errors,  Up: Top

4 Side effects
**************

This chapter describes potential side effects of calling
eclector.reader:read, eclector.reader:read-preserving-whitespace or
eclector.reader:read-from-string for different kinds of clients.

* Menu:

* Potential side effects for the default client::
* Potential side effects for non-default clients::


File: eclector.info,  Node: Potential side effects for the default client,  Next: Potential side effects for non-default clients,  Up: Side effects

4.1 Potential side effects for the default client
=================================================

The following destructive modifications are considered uninteresting and
ignored in the remainder of this section:

   • Changes to the state of streams passed to the functions mentioned
     above.

   • Changes to objects within expressions currently being read.

   Furthermore, the remainder of this section is written under the
following assumptions:

   • The stream object passed to eclector.reader:read does not cause
     additional side effects on its own.

   • The variable eclector.reader:*client* is bound to an object for
     which there are no custom applicable methods on generic functions
     belonging to protocols provided by Eclector that introduce
     additional side effects.

   • The variable eclector.readtable:*readtable* is bound to an object
     for which

        • there are no custom applicable methods on generic functions
          belonging to protocols provided by Eclector that introduce
          additional side effects

        • no non-default macro functions have been installed

   If any of the above assumptions does not hold, “all bets are off” in
the sense that arbitrary side effects other than the ones described
below are possible.  For notes regarding non-default clients, *Note
Potential side effects for non-default clients::.

* Menu:

* Symbols and packages (default client)::
* Read-time evaluation (default client)::
* Standard reader macros (default client)::


File: eclector.info,  Node: Symbols and packages (default client),  Next: Read-time evaluation (default client),  Up: Potential side effects for the default client

4.1.1 Symbols and packages (default client)
-------------------------------------------

The default method on the generic function
eclector.reader:interpret-symbol may create and intern symbols, thereby
modifying the package system.


File: eclector.info,  Node: Read-time evaluation (default client),  Next: Standard reader macros (default client),  Prev: Symbols and packages (default client),  Up: Potential side effects for the default client

4.1.2 Read-time evaluation (default client)
-------------------------------------------

The default method on the generic function
eclector.reader:evaluate-expression uses cl:eval to evaluate arbitrary
expressions, potentially causing side effects.  With the default
readtable, the generic function is only called by the macro function of
the #. reader macro.


File: eclector.info,  Node: Standard reader macros (default client),  Prev: Read-time evaluation (default client),  Up: Potential side effects for the default client

4.1.3 Standard reader macros (default client)
---------------------------------------------

The default method on the generic function
eclector.reader:call-reader-macro can cause side effects by calling
macro functions that cause side effects.  The following standard reader
macros potentially cause side-effects:

   • #. as described in *note Read-time evaluation (default client)::.


File: eclector.info,  Node: Potential side effects for non-default clients,  Prev: Potential side effects for the default client,  Up: Side effects

4.2 Potential side effects for non-default clients
==================================================

* Menu:

* Symbols and packages::
* Read-time evaluation::
* Structure instance creation::
* Circular structure::
* Standard reader macros::


File: eclector.info,  Node: Symbols and packages,  Next: Read-time evaluation,  Up: Potential side effects for non-default clients

4.2.1 Symbols and packages
--------------------------

In addition to the potential side effects described in *note Symbols and
packages (default client)::, strings passed as the third argument of
eclector.reader:interpret-token are potentially destructively modified
during conversion to the current readtable case.


File: eclector.info,  Node: Read-time evaluation,  Next: Structure instance creation,  Prev: Symbols and packages,  Up: Potential side effects for non-default clients

4.2.2 Read-time evaluation
--------------------------

The same considerations as in *note Read-time evaluation (default
client):: apply.


File: eclector.info,  Node: Structure instance creation,  Next: Circular structure,  Prev: Read-time evaluation,  Up: Potential side effects for non-default clients

4.2.3 Structure instance creation
---------------------------------

Clients defining methods on eclector.reader:make-structure-instance
which implement the standard behavior of calling the default constructor
(if any) of the named structure should consider side effects caused by
slot initforms of the structure.  The following example illustrates this
problem:
       (defvar *counter* 0)
       (defstruct foo (bar (incf *counter*)))
       #S(foo)
       *counter* ⇒ 1
       #S(foo)
       *counter* ⇒ 2


File: eclector.info,  Node: Circular structure,  Next: Standard reader macros,  Prev: Structure instance creation,  Up: Potential side effects for non-default clients

4.2.4 Circular structure
------------------------

The fixup generic function potentially modifies its second argument
destructively.  Clients that define methods on
eclector.reader:make-structure-instance should be aware of this
potential modification in cases like #1=#S(foo :bar #1#).  Similar
considerations apply for other ways of constructing compound objects
such as #1=(t . #1#).


File: eclector.info,  Node: Standard reader macros,  Prev: Circular structure,  Up: Potential side effects for non-default clients

4.2.5 Standard reader macros
----------------------------

The following standard reader macros could cause or be affected by side
effects when combined with a non-standard client:

   • #. as described in *note Read-time evaluation (default client)::.

   • #S as described in *note Structure instance creation::.

   • (, #( and #S as described in *note Circular structure::.

   • The ,. (i.e.  destructively splicing) variant of the , reader macro
     does not currently destructively modify the surrounding object, but
     clients should not rely on this fact.  This consideration applies
     to clients that install non-standard macro functions for the ( and
     #( reader macros.


File: eclector.info,  Node: Interpretation of unclear parts of the specification,  Next: Concept index,  Prev: Side effects,  Up: Top

5 Interpretation of unclear parts of the specification
******************************************************

This chapter describes Eclector’s interpretation of passages in the
Common Lisp specification that do not describe the behavior of a
conforming reader completely unambiguously.

* Menu:

* Interpretation of Sharpsign C and Sharpsign S::
* Interpretation of Backquote and Sharpsign Single Quote::
* Circular objects and custom reader macros::


File: eclector.info,  Node: Interpretation of Sharpsign C and Sharpsign S,  Next: Interpretation of Backquote and Sharpsign Single Quote,  Up: Interpretation of unclear parts of the specification

5.1 Interpretation of Sharpsign C and Sharpsign S
=================================================

At first glance, Sharpsign C and Sharpsign S seem to follow the same
syntactic structure: the dispatch macro character followed by the
sub-character followed by a list of a specific structure.  However, the
actual descriptions of the respective syntax is different.  For
Sharpsign C, the specification states:

     #C reads a following object, which must be a list of length two
     whose elements are both reals.

   For Sharpsign S, on the other hand, the specification describes the
syntax as:

     #s(NAME SLOT1 VALUE1 SLOT2 VALUE2 ...) denotes a structure.

   Note how the description for Sharpsign C relies on a recursive read
invocation while the description for Sharpsign S gives a character-level
pattern with meta-syntactic variables.  It is possible that this is an
oversight and the syntax was intended to be uniform between the two
reader macros.  Whatever the case may be, in order to provide conforming
behavior, Eclector is forced to implement Sharpsign C with a recursive
read invocation and Sharpsign S with a stricter enforcement of the
specified syntax.

   More concretely, Eclector behaves as summarized in the following
table:

Input                                Behavior
--------------------------------------------------------------------------
#C(1 2)                              Read as #C(1 2)
#C (1 2)                             Read as #C(1 2)
#C#||#(1 2)                          Read as #C(1 2)
#C#.(list 1 (+ 2 3))                 Read as #C(1 5)
#C[1 2] for left-parenthesis         Read as #C(1 2)
syntax on [                          
#S(foo)                              Read as #S(foo)
#S (foo)                             Rejected
#S#||#(foo)                          Rejected
#S#.(list 'foo)                      Rejected
#S[foo] for left-parenthesis         Rejected
syntax on [

   Eclector provides a strict version of the Sharpsign C macro function
under the name eclector.reader:strict-sharpsign-c which behaves as
follows:

Input                                Behavior
--------------------------------------------------------------------------
#C(1 2)                              Read as #C(1 2)
#C (1 2)                             Rejected
#C#||#(1 2)                          Rejected
#C#.(list 1 (+ 2 3))                 Rejected
#C[1 2] for left-parenthesis         Read as #C(1 2)
syntax on [


File: eclector.info,  Node: Interpretation of Backquote and Sharpsign Single Quote,  Next: Circular objects and custom reader macros,  Prev: Interpretation of Sharpsign C and Sharpsign S,  Up: Interpretation of unclear parts of the specification

5.2 Interpretation of Backquote and Sharpsign Single Quote
==========================================================

The Common Lisp specification is very specific about the contexts in
which the quasiquotation mechanism can be used.  Explicit descriptions
of the behavior of the quasiquotation mechanism are given for
expressions which _are_ lists or vectors and it is implied that unquote
is not allowed in other expressions.  From this description, it is clear
that `#S(foo :bar ,x) is not valid syntax, for example.  However,
whether `#',foo is valid syntax depends on whether #'THING is considered
to _be_ a list.  Since `#',foo is a relatively common idiom, Eclector
accepts it by default.

   Eclector provides a strict version of the Sharpsign Single Quote
macro function under the name
eclector.reader:strict-sharpsign-single-quote which does not accept
unquote in the function name.


File: eclector.info,  Node: Circular objects and custom reader macros,  Prev: Interpretation of Backquote and Sharpsign Single Quote,  Up: Interpretation of unclear parts of the specification

5.3 Circular objects and custom reader macros
=============================================

The Common Lisp specification describes the behavior of the ## reader
macro as follows:

     #N#, where N is a required unsigned decimal integer, provides a
     reference to some object labeled by #N=; that is, #N# represents a
     pointer to the same (eq) object labeled by #N=.

   The vague phrasing “represents a pointer to the same (eq) object” is
probably chosen to cover the situation in which the object in question
is not yet defined when the reader encounters the #N# reference as is
the case with input of the form #N=(…#N#…).  The fact that the object is
not yet defined when the reference is encountered is not a problem in
general except for one situation: assume #_ is a custom reader macro in
the current readtable which calls read.  In this situation, reading an
expression of the form #N=(…#_#N#…) causes the reader macro function for
#_ to be called which calls read to read the following object which
encounters the reference.  This chain of calls leads to a potential
problem: the read call made by the reader macro function has to return
some object but it cannot return the object labeled N since that object
has not been read yet.  The reader macro function must therefore receive
some sort of implementation-dependent (1) object which stands in for the
object labeled N and gets replaced at some later time after the object
labeled N has been read.  Since the stand-in object is
implementation-dependent, the reader macro function must not make any
assumptions regarding the type of the object or operate on it in any way
other than returning the object or using the object as a part of a
compound object.

   The following example violates this principle since the reader macro
function in custom-macro-readtable calls cl:second on the object
returned by eclector.reader:read:

     (defun custom-macro-readtable ()
       (let ((readtable (eclector.readtable:copy-readtable
                         eclector.reader:*readtable*)))
         (eclector.readtable:set-dispatch-macro-character
          readtable #\# #\_ (lambda (stream char sub-char)
                              (declare (ignore char sub-char))
                              (second (eclector.reader:read stream t nil t))))
         readtable))

     (let ((eclector.reader:*readtable* (custom-macro-readtable)))
       (eclector.reader:read-from-string "#1=(:a #_#1#)"))
     ⇒ undefined

   To handle the problem described above, Eclector imposes the following
restriction on custom reader macro functions which call read:

     A reader macro function which reads an object by calling read must
     account for the object being of an implementation-dependent type
     and must not operate on the object in any way other than returning
     the object or using the object as a part of a compound object.

   ---------- Footnotes ----------

   (1) We use “implementation-dependent” in the sense defined in the
Common Lisp specification except that Eclector is the implementation in
question.


File: eclector.info,  Node: Concept index,  Next: Function and macro and variable and type index,  Prev: Interpretation of unclear parts of the specification,  Up: Top

Concept index
*************

 [index ]
* Menu:

* client:                                Basic features.       (line  6)
* client <1>:                            Parse result construction features.
                                                               (line  6)
* complex literal:                       Interpretation of Sharpsign C and Sharpsign S.
                                                               (line  6)
* concrete syntax tree:                  Introduction.         (line  6)
* concrete syntax tree <1>:              Package for CST features.
                                                               (line  6)
* concrete syntax tree <2>:              CST reader features.  (line  6)
* error:                                 Recovering from errors.
                                                               (line  6)
* function:                              S-expression creation and quasiquotation.
                                                               (line 67)
* function <1>:                          Interpretation of Backquote and Sharpsign Single Quote.
                                                               (line  6)
* labeled object:                        Labeled objects and references.
                                                               (line  6)
* parse result:                          Introduction.         (line  6)
* parse result <1>:                      Package for parse result construction features.
                                                               (line  6)
* parse result <2>:                      Package for CST features.
                                                               (line  6)
* parse result <3>:                      Ordinary reader features.
                                                               (line  6)
* parse result <4>:                      Parse result construction features.
                                                               (line  6)
* parse result <5>:                      CST reader features.  (line  6)
* quasiquotation:                        S-expression creation and quasiquotation.
                                                               (line 18)
* quasiquote:                            Interpretation of Backquote and Sharpsign Single Quote.
                                                               (line  6)
* quotation:                             S-expression creation and quasiquotation.
                                                               (line  6)
* reader macro:                          Interpretation of Sharpsign C and Sharpsign S.
                                                               (line  6)
* reader macro <1>:                      Interpretation of Backquote and Sharpsign Single Quote.
                                                               (line  6)
* readtable:                             Package for readtable features.
                                                               (line  6)
* readtable <1>:                         Readtable initialization.
                                                               (line  6)
* readtable <2>:                         Readtable features.   (line  6)
* recovery:                              Recovering from errors.
                                                               (line  6)
* side effects:                          Side effects.         (line  6)
* source location:                       Basic features.       (line  6)
* source tracking:                       Introduction.         (line  6)
* source tracking <1>:                   Ordinary reader features.
                                                               (line  6)
* specification interpretation:          Interpretation of unclear parts of the specification.
                                                               (line  6)
* structure literal:                     Interpretation of Sharpsign C and Sharpsign S.
                                                               (line  6)


File: eclector.info,  Node: Function and macro and variable and type index,  Prev: Concept index,  Up: Top

Function and macro and variable and type index
**********************************************

 [index ]
* Menu:

* *client* [eclector.base]:              Basic features.      (line  54)
* *skip-reason* [eclector.reader]:       Reader behavior protocol.
                                                              (line  96)
* call-as-top-level-read [eclector.reader]: Reader behavior protocol.
                                                              (line  24)
* call-reader-macro [eclector.reader]:   Reader behavior protocol.
                                                              (line 219)
* call-with-current-package [eclector.reader]: Reader behavior protocol.
                                                              (line 278)
* call-with-label-tracking [eclector.reader]: Labeled objects and references.
                                                              (line 105)
* check-feature-expression [eclector.reader]: Reader behavior protocol.
                                                              (line 306)
* check-symbol-token [eclector.reader]:  Reader behavior protocol.
                                                              (line 137)
* evaluate-expression [eclector.reader]: Reader behavior protocol.
                                                              (line 293)
* evaluate-feature-expression [eclector.reader]: Reader behavior protocol.
                                                              (line 322)
* finalize-labeled-object [eclector.reader]: Labeled objects and references.
                                                              (line 223)
* find-character [eclector.reader]:      Reader behavior protocol.
                                                              (line 235)
* find-labeled-object [eclector.reader]: Labeled objects and references.
                                                              (line 167)
* fixup [eclector.reader]:               Labeled objects and references.
                                                              (line 307)
* fixup-graph [eclector.reader]:         Labeled objects and references.
                                                              (line 288)
* fixup-graph-p [eclector.reader]:       Labeled objects and references.
                                                              (line 264)
* forget-labeled-object [eclector.reader]: Labeled objects and references.
                                                              (line 152)
* interpret-symbol [eclector.reader]:    Reader behavior protocol.
                                                              (line 191)
* interpret-symbol-token [eclector.reader]: Reader behavior protocol.
                                                              (line 173)
* interpret-token [eclector.reader]:     Reader behavior protocol.
                                                              (line 119)
* labeled-object-state [eclector.reader]: Labeled objects and references.
                                                              (line 196)
* make-expression-result [eclector.parse-result]: Parse result construction features.
                                                              (line  90)
* make-labeled-object [eclector.reader]: Labeled objects and references.
                                                              (line 178)
* make-skipped-input-result [eclector.parse-result]: Parse result construction features.
                                                              (line 107)
* make-source-range [eclector.base]:     Basic features.      (line  75)
* make-structure-instance [eclector.reader]: Reader behavior protocol.
                                                              (line 260)
* note-labeled-object [eclector.reader]: Labeled objects and references.
                                                              (line 118)
* note-skipped-input [eclector.reader]:  Reader behavior protocol.
                                                              (line  78)
* parse-result-client [eclector.parse-result]: Parse result construction features.
                                                              (line  85)
* position-offset [eclector.base]:       Basic features.      (line  39)
* read [eclector.concrete-syntax-tree]:  CST reader features. (line  10)
* read [eclector.parse-result]:          Parse result construction features.
                                                              (line  37)
* read [eclector.reader]:                Common Lisp reader compatible interface.
                                                              (line  12)
* read-common [eclector.reader]:         Reader behavior protocol.
                                                              (line  42)
* read-delimited-list [eclector.reader]: Common Lisp reader compatible interface.
                                                              (line  34)
* read-from-string [eclector.concrete-syntax-tree]: CST reader features.
                                                              (line  33)
* read-from-string [eclector.parse-result]: Parse result construction features.
                                                              (line  69)
* read-from-string [eclector.reader]:    Common Lisp reader compatible interface.
                                                              (line  27)
* read-maybe-nothing [eclector.reader]:  Reader behavior protocol.
                                                              (line  53)
* read-preserving-whitespace [eclector.concrete-syntax-tree]: CST reader features.
                                                              (line  25)
* read-preserving-whitespace [eclector.parse-result]: Parse result construction features.
                                                              (line  61)
* read-preserving-whitespace [eclector.reader]: Common Lisp reader compatible interface.
                                                              (line  20)
* read-token [eclector.reader]:          Reader behavior protocol.
                                                              (line 111)
* readtablep [eclector.readtable]:       Readtable features.  (line  19)
* recover [eclector.reader]:             Error recovery features.
                                                              (line  14)
* reference-labeled-object [eclector.reader]: Labeled objects and references.
                                                              (line 236)
* set-standard-dispatch-macro-characters [eclector.reader]: Readtable initialization.
                                                              (line  21)
* set-standard-macro-characters [eclector.reader]: Readtable initialization.
                                                              (line  16)
* set-standard-syntax-and-macros [eclector.reader]: Readtable initialization.
                                                              (line  28)
* set-standard-syntax-types [eclector.reader]: Readtable initialization.
                                                              (line  11)
* source-position [eclector.base]:       Basic features.      (line  63)
* stream-position [eclector.base]:       Basic features.      (line  28)
* stream-position-condition [eclector.base]: Basic features.  (line  16)
* with-forbidden-quasiquotation [eclector.reader]: S-expression creation and quasiquotation.
                                                              (line  53)
* wrap-in-function [eclector.reader]:    S-expression creation and quasiquotation.
                                                              (line  67)
* wrap-in-quasiquote [eclector.reader]:  S-expression creation and quasiquotation.
                                                              (line  18)
* wrap-in-quote [eclector.reader]:       S-expression creation and quasiquotation.
                                                              (line   9)
* wrap-in-unquote [eclector.reader]:     S-expression creation and quasiquotation.
                                                              (line  27)
* wrap-in-unquote-splicing [eclector.reader]: S-expression creation and quasiquotation.
                                                              (line  36)



Tag Table:
Node: Top296
Node: Introduction677
Ref: Introduction-Footnote-11787
Node: External protocols1859
Node: Packages2171
Node: Package for basic features2483
Node: Package for ordinary reader features2945
Node: Package for readtable features3541
Node: Package for parse result construction features4149
Node: Package for CST features4819
Node: Basic features5407
Ref: Class eclector.base|stream-position-condition6096
Ref: Generic-Function eclector.base|stream-position6772
Ref: Generic-Function eclector.base|position-offset7255
Ref: Variable eclector.base|*client*7973
Ref: Generic-Function eclector.base|source-position8425
Ref: Generic-Function eclector.base|make-source-range8995
Node: Ordinary reader features9458
Ref: fig:read-call-sequence-ordinary10576
Node: Common Lisp reader compatible interface11382
Ref: Function eclector.reader|read11902
Ref: Function eclector.reader|read-preserving-whitespace12217
Ref: Function eclector.reader|read-from-string12496
Ref: Function eclector.reader|read-delimited-list12773
Node: Reader behavior protocol13008
Ref: fig:read-call-sequence-customization13370
Ref: Generic-Function eclector.reader|call-as-top-level-read14025
Ref: Generic-Function eclector.reader|read-common14943
Ref: Generic-Function eclector.reader|read-maybe-nothing15471
Ref: Generic-Function eclector.reader|note-skipped-input16614
Ref: Variable eclector.reader|*skip-reason*17569
Ref: Generic-Function eclector.reader|read-token18353
Ref: Generic-Function eclector.reader|interpret-token18739
Ref: Generic-Function eclector.reader|check-symbol-token19796
Ref: Generic-Function eclector.reader|interpret-symbol-token21669
Ref: Generic-Function eclector.reader|interpret-symbol22660
Ref: Generic-Function eclector.reader|call-reader-macro23876
Ref: Generic-Function eclector.reader|find-character24704
Ref: Generic-Function eclector.reader|make-structure-instance25946
Ref: Generic-Function eclector.reader|call-with-current-package26784
Ref: Generic-Function eclector.reader|evaluate-expression27498
Ref: Generic-Function eclector.reader|check-feature-expression28063
Ref: Generic-Function eclector.reader|evaluate-feature-expression28889
Node: Labeled objects and references29972
Ref: fig:labeled-object-states31876
Ref: fig:labeled-object-api-states33082
Ref: Generic-Function eclector.reader|call-with-label-tracking35681
Ref: Generic-Function eclector.reader|note-labeled-object36225
Ref: Generic-Function eclector.reader|forget-labeled-object38090
Ref: Generic-Function eclector.reader|find-labeled-object38822
Ref: Generic-Function eclector.reader|make-labeled-object39327
Ref: Generic-Function eclector.reader|labeled-object-state40295
Ref: Generic-Function eclector.reader|finalize-labeled-object41508
Ref: Generic-Function eclector.reader|reference-labeled-object42157
Ref: Generic-Function eclector.reader|fixup-graph-p43699
Ref: Generic-Function eclector.reader|fixup-graph44778
Ref: Generic-Function eclector.reader|fixup45679
Ref: Labeled objects and references-Footnote-147208
Ref: Labeled objects and references-Footnote-247380
Node: S-expression creation and quasiquotation47509
Ref: Generic-Function eclector.reader|wrap-in-quote47888
Ref: Generic-Function eclector.reader|wrap-in-quasiquote48246
Ref: Generic-Function eclector.reader|wrap-in-unquote48616
Ref: Generic-Function eclector.reader|wrap-in-unquote-splicing48971
Ref: Macro eclector.reader|with-forbidden-quasiquotation49725
Ref: Generic-Function eclector.reader|wrap-in-function50477
Node: Readtable initialization50849
Ref: Function eclector.reader|set-standard-syntax-types51297
Ref: Function eclector.reader|set-standard-macro-characters51466
Ref: Function eclector.reader|set-standard-dispatch-macro-characters51641
Ref: Function eclector.reader|set-standard-syntax-and-macros51894
Node: Readtable features52096
Ref: Generic-Function eclector.readtable|readtablep52857
Node: Parse result construction features53209
Ref: fig:read-call-sequence-parse-result54390
Ref: Function eclector.parse-result|read54967
Ref: Function eclector.parse-result|read-preserving-whitespace56062
Ref: Function eclector.parse-result|read-from-string56417
Ref: Class eclector.parse-result|parse-result-client57096
Ref: Generic-Function eclector.parse-result|make-expression-result57254
Ref: Generic-Function eclector.parse-result|make-skipped-input-result58103
Node: CST reader features59684
Ref: Function eclector.concrete-syntax-tree|read59994
Ref: Function eclector.concrete-syntax-tree|read-preserving-whitespace60616
Ref: Function eclector.concrete-syntax-tree|read-from-string60972
Node: Recovering from errors61334
Node: Error recovery features61581
Ref: Function eclector.reader|recover62193
Node: Recoverable errors63010
Node: Potential problems64502
Node: Side effects65133
Node: Potential side effects for the default client65612
Node: Symbols and packages (default client)67305
Node: Read-time evaluation (default client)67707
Node: Standard reader macros (default client)68284
Node: Potential side effects for non-default clients68843
Node: Symbols and packages69239
Node: Read-time evaluation69691
Node: Structure instance creation70000
Node: Circular structure70682
Node: Standard reader macros71241
Node: Interpretation of unclear parts of the specification72075
Node: Interpretation of Sharpsign C and Sharpsign S72668
Node: Interpretation of Backquote and Sharpsign Single Quote75324
Node: Circular objects and custom reader macros76469
Ref: Circular objects and custom reader macros-Footnote-179611
Node: Concept index79767
Node: Function and macro and variable and type index84005

End Tag Table


Local Variables:
coding: utf-8
End:
