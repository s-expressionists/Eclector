This is eclector.info, produced by makeinfo version 6.7 from
eclector.texi.

Copyright © 2010 - 2018 Robert Strandh Copyright © 2018 - 2020 Jan
Moringen
INFO-DIR-SECTION Common Lisp
START-INFO-DIR-ENTRY
* Eclector User’s Manual: (eclector). A portable Common Lisp reader.
END-INFO-DIR-ENTRY


File: eclector.info,  Node: Top,  Next: Introduction,  Up: (dir)

Eclector User’s Manual
**********************

This manual is for Eclector version TODO.

* Menu:

* Introduction::
* External protocols::
* Recovering from errors::
* Side effects::
* Interpretation of Unclear Parts of the Specifications::
* Concept index::
* Function and macro and variable and type index::


File: eclector.info,  Node: Introduction,  Next: External protocols,  Prev: Top,  Up: Top

1 Introduction
**************

Eclector is a portable, implementation-independent version of the Common
Lisp function read, a corresponding readtable and a quasiquotation
facility.  As opposed to existing implementation-specific versions of
read, Eclector uses generic functions to allow clients to customize the
exact behavior, such as the interpretation of tokens.

   Another unusual feature of Eclector is its ability to, at the
discretion of the client, recover from many syntax errors, continue
reading and return a result that somewhat resembles what would have been
returned in case the syntax had been valid.

   Furthermore, Eclector can be used as a _source tracking_ reader,
which is accomplished through a mode of operation that produces _parse
results_ which wrap the Common Lisp expressions in objects that can also
contain information about the positions in the source code of those
expressions.  One example of such parse results are _concrete syntax
trees_ (1).

   ---------- Footnotes ----------

   (1) See: <https://github.com/s-expressionists/Concrete-Syntax-Tree>


File: eclector.info,  Node: External protocols,  Next: Recovering from errors,  Prev: Introduction,  Up: Top

2 External protocols
********************

* Menu:

* Packages::
* Basic features::
* Ordinary reader features::
* Readtable features::
* Parse result construction features::
* CST reader features::


File: eclector.info,  Node: Packages,  Next: Basic features,  Up: External protocols

2.1 Packages
============

* Menu:

* Package for basic features::
* Package for ordinary reader features::
* Package for readtable features::
* Package for parse result construction features::
* Package for CST features::


File: eclector.info,  Node: Package for basic features,  Next: Package for ordinary reader features,  Up: Packages

2.1.1 Package for basic features
--------------------------------

The package for basic features such as customizable source location
construction is named eclector.base.  Although this package does not
shadow any symbol in the common-lisp package, we still recommend the use
of explicit package prefixes to refer to symbols in this package.


File: eclector.info,  Node: Package for ordinary reader features,  Next: Package for readtable features,  Prev: Package for basic features,  Up: Packages

2.1.2 Package for ordinary reader features
------------------------------------------

The package for ordinary reader features is named eclector.reader.  To
use features of this package, we recommend the use of explicit package
prefixes, simply because this package shadows and exports names that are
also exported from the common-lisp package.  Importing this package will
likely cause conflicts with the common-lisp package otherwise.


File: eclector.info,  Node: Package for readtable features,  Next: Package for parse result construction features,  Prev: Package for ordinary reader features,  Up: Packages

2.1.3 Package for readtable features
------------------------------------

The package for readtable-related features is named eclector.readtable.
To use features of this package, we recommend the use of explicit
package prefixes, simply because this package shadows and exports names
that are also exported from the common-lisp package.  Importing this
package will likely cause conflicts with the common-lisp package
otherwise.


File: eclector.info,  Node: Package for parse result construction features,  Next: Package for CST features,  Prev: Package for readtable features,  Up: Packages

2.1.4 Package for parse result construction features
----------------------------------------------------

The package for features related to the creation of client-defined parse
results is named eclector.parse-result.  To use features of this
package, we recommend the use of explicit package prefixes, simply
because this package shadows and exports names that are also exported
from the common-lisp package.  Importing this package will likely cause
conflicts with the common-lisp package otherwise.


File: eclector.info,  Node: Package for CST features,  Prev: Package for parse result construction features,  Up: Packages

2.1.5 Package for CST features
------------------------------

The package for features related to the creation of concrete syntax
trees is named eclector.concrete-syntax-tree.  To use features of this
package, we recommend the use of explicit package prefixes, simply
because this package shadows and exports names that are also exported
from the common-lisp package.  Importing this package will likely cause
conflicts with the common-lisp package otherwise.


File: eclector.info,  Node: Basic features,  Next: Ordinary reader features,  Prev: Packages,  Up: External protocols

2.2 Basic features
==================

In this section, symbols written without package marker are in the
eclector.base package (*note Package for basic features::).

   This package provides the mechanism that enables clients to customize
the behavior of the reader.  Furthermore this package provides a
protocol for customizing a particular aspect of the behavior, namely the
construction of source positions and source ranges.  Eclector uses
source positions and source ranges in signaled conditions and parse
results (*note Parse result construction features::).

 -- Class: stream-position-condition [eclector.base]

     This condition type is the supertype of all conditions which are
     signaled by Eclector functions.  An instance of this condition type
     stores an approximate position in an input stream.  The condition
     is associated with the stream content at the designated position.
     The position uses a representation which is controlled by the
     respective client by adding a method on the source-position generic
     function.

 -- Generic Function: stream-position [eclector.base] condition

     This generic function can be called by clients in order to obtain
     the approximate position in the input stream to which CONDITION
     pertains.  The type and interpretation of the returned object
     depend on the client, namely the presence of client-specific
     methods on the source-position generic function.

     Applicable methods exist for all conditions of type
     stream-position-condition.

 -- Variable: *client* [eclector.base]

     This variable is used by several generic functions which are called
     by eclector.reader:read.  The default value of the variable is nil.
     Clients that want to override or extend the default behavior of
     some generic function of Eclector should bind this variable to some
     standard object and provide a method on that generic function,
     specialized to the class of that standard object.

 -- Generic Function: source-position [eclector.base] client stream

     This generic function is called in order to determine the current
     position in STREAM.  Eclector does not inspect or manipulate the
     objects returned by this generic function beyond storing them in
     signaled conditions and passing them as arguments to the
     make-source-range generic function.  A client is therefore free to
     define methods on this generic function that return arbitrary
     objects.

     The default method on this generic function calls cl:file-position.

 -- Generic Function: make-source-range [eclector.base] client start end

     This generic function is called in order to turn the source
     positions START and END into a range representation suitable for
     CLIENT.  The returned representation designates the range of input
     characters from and including the character at position START to
     but not including the character at position END.  The default
     method returns ‘(cons START END)’.


File: eclector.info,  Node: Ordinary reader features,  Next: Readtable features,  Prev: Basic features,  Up: External protocols

2.3 Ordinary reader features
============================

In this section, symbols written without package marker are in the
eclector.reader package (*note Package for ordinary reader features::)

   The features provided in this package fall into two categories:
   • The functions read, read-preserving-whitespace, read-from-string
     and read-delimited-list which, together with standard special
     variables, replicate the interface of the standard Common Lisp
     reader (except functions related to readtables which Eclector
     provides separately, *note Readtable features::).  These functions
     are discussed in the section *note Common Lisp reader compatible
     interface::.

   • The second category is comprised of the eclector.base:*client*
     special variable and a collection of protocols which allow
     customizing the behavior of the reader by defining methods
     specialized to a particular client on the generic functions of the
     protocols.

              [image src="read-call-sequence-ordinary.png" ]

Figure 2.1: Functions and typical function call sequences.  Solid arrows
represent calls, dashed arrows represent returns from function calls.
Labels above arrows represent arguments and return values.

   *note Figure 2.1: fig:read-call-sequence-ordinary. illustrates the
categorization into the Common Lisp reader compatible interface and the
extensible behavior protocol as well as typical function call patterns
that arise when the functions read, read-preserving-whitespace,
read-from-string and read-delimited-list are called by client code.

* Menu:

* Common Lisp reader compatible interface::
* Reader behavior protocol::
* S-expression creation and quasiquotation::
* Readtable initialization::


File: eclector.info,  Node: Common Lisp reader compatible interface,  Next: Reader behavior protocol,  Up: Ordinary reader features

2.3.1 Common Lisp reader compatible interface
---------------------------------------------

The following functions are like their standarad Common Lisp
counterparts with the two differences that their names are symbols in
the eclector.reader package and that their behavior can deviate from
that of the standard reader depending on the value of the
eclector.base:*client* variable.

 -- Function: read [eclector.reader] &optional (input-stream
          *standard-input*) (eof-error-p t) (eof-value nil) (recursive-p
          nil)

     This function is the main entry point for the ordinary reader.  It
     is entirely compatible with the standard Common Lisp function with
     the same name.

 -- Function: read-preserving-whitespace [eclector.reader] &optional
          (input-stream *standard-input*) (eof-error-p t) (eof-value
          nil) (recursive-p nil)

     This function is entirely compatible with the standard Common Lisp
     function with the same name.

 -- Function: read-from-string [eclector.reader] string &optional
          (eof-error-p t) (eof-value nil) &key (start 0) (end nil)
          (preserve-whitespace nil)

     This function is entirely compatible with the standard Common Lisp
     function with the same name.

 -- Function: read-delimited-list [eclector.reader] char &optional
          (input-stream *standard-input*) (recursive-p nil)

     This function is entirely compatible with the standard Common Lisp
     function with the same name.


File: eclector.info,  Node: Reader behavior protocol,  Next: S-expression creation and quasiquotation,  Prev: Common Lisp reader compatible interface,  Up: Ordinary reader features

2.3.2 Reader behavior protocol
------------------------------

By defining methods on the generic functions of this protocol, clients
can customize the high-level behavior of the reader.

           [image src="read-call-sequence-customization.png" ]

Figure 2.2: Functions and typical function call sequences terminating on
the right hand side of the diagram at customizable generic functions
which implement aspects of the reader algorithm and standard reader
macros.  Solid arrows represent calls, dashed arrows represent returns
from function calls.  Labels above arrows represent arguments and return
values.

   *note Figure 2.2: fig:read-call-sequence-customization. illustrates
how the customizable generic functions described in this section are
called through the client interface and the implementation of the reader
algorithm.

 -- Generic Function: call-as-top-level-read [eclector.reader] client
          thunk input-stream eof-error-p eof-value preserve-whitespace-p

     This generic function is called by read if read is called with a
     false value for the RECURSIVE-P parameter.  It calls THUNK with the
     necessary context for a global read call.  THUNK should read and
     return an object without consuming any whitespace following the
     object.  If PRESERVE-WHITESPACE-P is false, this function reads up
     to one character of whitespace after THUNK returns.  This function
     returns the object or EOF-VALUE returned by THUNK as its first
     value.  It may return additional values.

     The default method on this generic function performs two tasks:
       1. It establishes a context in which labels (#N=) and references
          (#N#) work.

       2. It realizes the requested PRESERVE-WHITESPACE-P behavior.

 -- Generic Function: read-common [eclector.reader] client input-stream
          eof-error-p eof-value

     This generic function is called by read, passing it the value of
     the variable eclector.base:*client* and the corresponding
     parameters.  Client code can add methods on this function,
     specializing them to the client class of its choice.  The actions
     that read needs to take for different values of the parameter
     RECURSIVE-P have already been taken before read calls this generic
     function.

 -- Generic Function: read-maybe-nothing [eclector.reader] client
          input-stream eof-error-p eof-value

     This generic function can be called directly by the client or by
     the generic function read-common to read an object or consume input
     without returning an object.  If called directly by the client, the
     call has to be in the dynamic scope of a call-as-top-level-read
     call.  The function read-maybe-nothing either

        • encounters the end of input on INPUT-STREAM and, depending on
          EOF-ERROR-P either signals an error or returns the values
          EOF-VALUE and :eof

        • or reads one or more whitespace characters an returns the
          values nil and :whitespace

        • or reads an object.  If *read-suppress* is true, the function
          returns nil and :suppress.  Otherwise it returns the object
          and :object.

        • or consumes a macro character and the characters consumed by
          the associated reader macro function if that reader macro
          function does not return a value.  In this case the function
          returns nil and :skip.

 -- Generic Function: note-skipped-input [eclector.reader] client
          input-stream reason

     This generic function is called whenever the reader skips some
     input such as a comment or a form that must be skipped because of a
     reader conditional.  It is called with the value of the variable
     eclector.base:*client*, the input stream from which the input is
     being read and an object indicating the reason for skipping the
     input.  The default method on this generic function does nothing.
     Client code can supply a method that specializes to the client
     class of its choice.

     When this function is called, the stream is positioned immediately
     _after_ the skipped input.  Client code that wants to know both the
     beginning and the end of the skipped input must remember the stream
     position before the call to read was made as well as the stream
     position when the call to this function is made.

 -- Variable: *skip-reason* [eclector.reader]

     This variable is used by the reader to determine why a range of
     input characters has been skipped.  To this end, internal functions
     of the reader as well as reader macros can set this variable to a
     suitable value before skipping over some input.  Then, after the
     input has been skipped, the generic function note-skipped-input is
     called with the value of the variable as its REASON argument.

     As an example, the method on note-skipped-input specialized to
     eclector.parse-result:parse-result-client relays the reason and
     position information to the client by calling the
     eclector.parse-result:make-skipped-input-result generic function
     (*note Parse result construction features::).

 -- Generic Function: read-token [eclector.reader] client input-stream
          eof-error-p eof-value

     This generic function is called by read-common when it has been
     detected that a token should be read.  This function is responsible
     for accumulating the characters of the token and then calling
     interpret-token (see below) in order to create and return a token.

 -- Generic Function: interpret-token [eclector.reader] client
          input-stream token escape-ranges

     This generic function is called by read-token in order to create a
     token from accumulated token characters.  The parameter TOKEN is a
     string containing the characters that make up the token.  The
     parameter ESCAPE-RANGES indicates ranges of characters read from
     INPUT-STREAM and preceded by a character with single-escape syntax
     or delimited by characters with multiple-escape syntax.  Values of
     ESCAPE-RANGES are lists of elements of the form (START\ .\ END)
     where START is the index of the first escaped character and END is
     the index _following_ the last escaped character.  Note that START
     and VAR can be identical indicating no escaped characters.  This
     can happen in cases like a||b.  The information conveyed by the
     ESCAPE-RANGES parameter is used to convert the characters in TOKEN
     according to the _readtable case_ of the current readtable before a
     token is constructed.

 -- Generic Function: check-symbol-token [eclector.reader] client
          input-stream token escape-ranges position-package-marker-1
          position-package-marker-2

     This generic function is called by the default method on
     interpret-token when the syntax of the token corresponds to that of
     a symbol.  This function checks the syntactic validity of the
     symbol token and signals an error in case of a syntax error.  If
     there are no syntax errors (or error recovery has been performed,
     *note Recovering from errors::), this function returns three
     values:
       1. TOKEN or a value derived from TOKEN by error recovery
          operations.

       2. POSITION-PACKAGE-MARKER-1 or a value derived from
          POSITION-PACKAGE-MARKER-1 by error recovery operations.

       3. POSITION-PACKAGE-MARKER-2 or a value derived from
          POSITION-PACKAGE-MARKER-2 by error recovery operations.

     The parameter INPUT-STREAM is the input stream from which the
     characters were read.  The parameter TOKEN is a string that
     contains all the characters of the token.  The parameter
     ESCAPE-RANGES indicates ranges within TOKEN that were preceded by a
     character with single-escape syntax or delimited by characters with
     multiple-escape syntax.  The parameter POSITION-PACKAGE-MARKER-1
     contains the index into TOKEN of the first package marker, or nil
     if the token contains no package markers.  The parameter
     POSITION-PACKAGE-MARKER-2 contains the index into TOKEN of the
     second package marker, or nil if the token contains no package
     markers or only a single package marker.

     The default method on this generic function checks the positions of
     the package markers taking into account escape ranges.  The method
     signals errors and allows error recovery as described above.

 -- Generic Function: interpret-symbol-token [eclector.reader] client
          input-stream token position-package-marker-1
          position-package-marker-2

     This generic function is called by the default method on
     interpret-token when the syntax of the token corresponds to that of
     a valid symbol.  The parameter INPUT-STREAM is the input stream
     from which the characters were read.  The parameter TOKEN is a
     string that contains all the characters of the token.  The
     parameter POSITION-PACKAGE-MARKER-1 contains the index into TOKEN
     of the first package marker, or nil if the token contains no
     package markers.  The parameter POSITION-PACKAGE-MARKER-2 contains
     the index into TOKEN of the second package marker, or nil if the
     token contains no package markers or only a single package marker.

     The default method on this generic function calls interpret-symbol
     (see below) with a symbol name string and a package indicator.

 -- Generic Function: interpret-symbol [eclector.reader] client
          input-stream package-indicator symbol-name internp

     This generic function is called by the default method on
     interpret-symbol-token as well as the default #: reader macro
     function to resolve a symbol name string and a package indicator to
     a representation of the designated symbol.  The parameter
     INPUT-STREAM is the input stream from which PACKAGE-INDICATOR and
     SYMBOL-NAME were read.  The parameter PACKAGE-INDICATOR is a either

        • a string designating the package of that name

        • the keyword :current designating the current package

        • the keyword :keyword designating the keyword package

        • nil to indicate that an uninterned symbol should be created

     The SYMBOL-NAME is the name of the desired symbol.

     The default method uses cl:find-package (or cl:*package* when
     PACKAGE-INDICATOR is :current) to resolve PACKAGE-INDICATOR
     followed by cl:find-symbol or cl:intern, depending on INTERNP, to
     resolve SYMBOL-NAME.

     A second method which is specialized on PACKAGE-INDICATOR being nil
     uses cl:make-symbol to create uninterned symbols.

 -- Generic Function: call-reader-macro [eclector.reader] client
          input-stream char readtable

     This generic function is called when the reader has determined that
     some character is associated with a reader macro.  The parameter
     CHAR has to be used in conjunction with the READTABLE parameter to
     obtain the macro function that is associated with the macro
     character.  The parameter INPUT-STREAM is the input stream from
     which the reader macro function will read additional input to
     accomplish its task.

     The default method on this generic function simply obtains the
     reader macro function for CHAR from READTABLE and calls it, passing
     INPUT-STREAM and CHAR as arguments.  The default method therefore
     does the same thing that the standard Common Lisp reader does.

 -- Generic Function: find-character [eclector.reader] client name

     This generic function is called by the default #\ reader macro
     function to find a character by name.  NAME is the name that has
     been read converted to upper case.  The function has to either
     return the character designated by NAME or nil if no such character
     exists.

 -- Generic Function: make-structure-instance [eclector.reader] client
          name initargs

     This generic function is called by the default #S reader macro
     function to construct structure instances.  NAME is a symbol naming
     the structure type of which an instance should be constructed.
     INITARGS is a list the elements of which alternate between string
     designators naming structure slots and values for those slots.

     It is the responsibility of the client to coerce the string
     designators to symbols as if by ‘(intern (string slot-name)
     (find-package 'keyword))’ as described in the Common Lisp
     specification.

     There is no default method on this generic function since there is
     no portable way to construct structure instances given only the
     name of the structure type.

 -- Generic Function: call-with-current-package [eclector.reader] client
          thunk package-designator

     This generic function is called by the reader when input has to be
     read with a particular current package.  This is currently only the
     case in the #+ and #- reader macro functions which read feature
     expressions in the keyword package.  THUNK is a function that
     should be called without arguments.  PACKAGE-DESIGNATOR designates
     the package that should be the current package around the call to
     THUNK.

     The default method on this generic function simply binds
     cl:*package* to the result of ‘(cl:find-package
     PACKAGE-DESIGNATOR)’ around calling THUNK.

 -- Generic Function: evaluate-expression [eclector.reader] client
          expression

     This generic function is called by the default #. reader macro
     function to perform read-time evaluation.  EXPRESSION is the
     expression that should be evaluated as it was returned by a
     recursive read call and potentially influenced by CLIENT.  The
     function has to either return the result of evaluating EXPRESSION
     or signal an error.

     The default method on this generic function simply returns the
     result of ‘(cl:eval EXPRESSION)’.

 -- Generic Function: check-feature-expression [eclector.reader] client
          feature-expression

     This generic function is called by the default #+ and #- reader
     macro functions to check the well-formedness of FEATURE-EXPRESSION
     which has been read from the input stream before evaluating it.
     For compound expressions, only the outermost expression is checked
     regarding the atom in operator position and its shape – child
     expressions are not checked.  The function returns an unspecified
     value if FEATURE-EXPRESSION is well-formed and signals an error
     otherwise.

     The default method on this generic function accepts standard Common
     Lisp feature expression, i.e.  expressions recursively composed of
     symbols, :not-expressions, :and-expressions and :or-expressions.

 -- Generic Function: evaluate-feature-expression [eclector.reader]
          client feature-expression

     This generic function is called by the default #+ and #- reader
     macro functions to evaluate FEATURE-EXPRESSION which has been read
     from the input stream.  The function returns either true or false
     if FEATURE-EXPRESSION is well-formed and signals an error
     otherwise.

     For compound feature expressions, the well-formedness of child
     expressions is not checked immediately but lazily, just before the
     child expression in question is evaluated in a subsequent
     evaluate-feature-expression call.  This allows expressions like
     ‘#+(and my-cl-implementation (special-feature a b)) FORM’ to be
     read without error when the :my-cl-implementation feature is
     absent.

     The default method on this generic function first calls
     check-feature-expression to check the well-formedness of
     FEATURE-EXPRESSION.  It then evaluates FEATURE-EXPRESSION according
     to standard Common Lisp semantics for feature expressions.

 -- Generic Function: fixup [eclector.reader] client object seen-objects
          mapping

     This generic function is potentially called to apply
     circularity-related changes to the object constructed by the reader
     before it is returned to the caller.  OBJECT is the object that
     should be modified.  SEEN-OBJECTS is a eq-hash table used to track
     already processed objects (see below).  MAPPING is a hash table of
     substitutions, mapping marker objects to replacement objects.  A
     method specialized on a class, instances of which consists of
     parts, should modify OBJECT by scanning its parts for marker
     objects, replacing found markers with replacement object and
     recursively calling fixup for all parts.  fixup is called for side
     effects – its return value is ignored.

     Default methods specializing on the OBJECT parameter for cons,
     array, standard-object and hash-table process instances of those
     classes in the obvious way.

     An unspecialized :around method queries and updates SEEN-OBJECTS to
     ensure that each object is processed exactly once.


File: eclector.info,  Node: S-expression creation and quasiquotation,  Next: Readtable initialization,  Prev: Reader behavior protocol,  Up: Ordinary reader features

2.3.3 S-expression creation and quasiquotation
----------------------------------------------

The following generic functions allow clients to construct
representations of quoted and quasiquoted forms.

 -- Generic Function: wrap-in-quote [eclector.reader] client material

     This generic function is called by the default '-reader macro
     function to construct a quotation form in which MATERIAL is the
     quoted material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'common-lisp:quote MATERIAL)’.

 -- Generic Function: wrap-in-quasiquote [eclector.reader] client form

     This generic function is called by the default `-reader macro
     function to construct a quasiquotation form in which FORM is the
     quasiquoted material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'eclector.reader:quasiquote FORM)’.

 -- Generic Function: wrap-in-unquote [eclector.reader] client form

     This generic function is called by the default ,-reader macro
     function to construct an unquote form in which FORM is the unquoted
     material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'eclector.reader:unquote FORM)’.

 -- Generic Function: wrap-in-unquote-splicing [eclector.reader] client
          form

     This generic function is called by the default ,@-reader macro
     function to construct a splicing unquote form in which FORM is the
     unquoted material.

     The default method on this generic function returns a result
     equivalent to ‘(list 'eclector.reader:unquote-splicing FORM)’.

   Backquote and unquote syntax is forbidden in some contexts such as
multi-dimensional array literals (#A) and structure literals (#S) thus
Eclector has a mechanism for controlling whether backquote, unquote or
both should be allowed in a given context.  Since custom reader macros
may also have to control this aspect, Eclector provides an external
protocol:

 -- Macro: with-forbidden-quasiquotation [eclector.reader] context
          &optional (quasiquote-forbidden-p t) (unquote-forbidden-p t)
          &body body

     Disallow backquote syntax, unquote syntax or both in read functions
     called during the execution of BODY.  CONTEXT is a symbol
     identifying the current context which is used for error reporting.
     A typical value is the name of the reader macro function in which
     this macro is used.  QUASIQUOTE-FORBIDDEN-P controls whether
     backquote syntax should be forbidden.  The value :keep causes the
     binding to remain unchanged.  UNQUOTE-FORBIDDEN-P controls whether
     unquote syntax should be forbidden.  The value :keep causes the
     binding to remain unchanged.

 -- Generic Function: wrap-in-function [eclector.reader] client name

     This generic function is called by the default #'-reader macro
     function to construct a form that applies the function special
     operator to the NAME expression.

     The default method on this generic function returns a result
     equivalent to ‘(list 'common-lisp:function FORM)’.


File: eclector.info,  Node: Readtable initialization,  Prev: S-expression creation and quasiquotation,  Up: Ordinary reader features

2.3.4 Readtable initialization
------------------------------

The standard syntax types and macro character associations used by the
ordinary reader can be set up for any readtable object implementing the
readtable protocol (*note Readtable features::).  The following
functions are provided for this purpose:

 -- Function: set-standard-syntax-types [eclector.reader] readtable

     This function sets the standard syntax types in READTABLE (See
     HyperSpec section 2.1.4.)

 -- Function: set-standard-macro-characters [eclector.reader] readtable

     This function sets the standard macro characters in READTABLE (See
     HyperSpec section 2.4.)

 -- Function: set-standard-dispatch-macro-characters [eclector.reader]
          readtable

     This function sets the standard dispatch macro characters, that is
     sharpsign and its sub-characters, in READTABLE (See HyperSpec
     section 2.4.8.)

 -- Function: set-standard-syntax-and-macros [eclector.reader] readtable

     This function sets the standard syntax types and macro characters
     in READTABLE by calling the above three functions.


File: eclector.info,  Node: Readtable features,  Next: Parse result construction features,  Prev: Ordinary reader features,  Up: External protocols

2.4 Readtable features
======================

In this section, symbols written without package marker are in the
eclector.readtable package (*note Package for readtable features::).

   This package exports two kinds of symbols:

  1. Symbols the names of which correspond to the names of symbols in
     the common-lisp package.  The functions bound to these symbols are
     generic versions of the corresponding standard Common Lisp
     functions.  Clients can define custom readtables by defining
     methods on these generic functions.

  2. Symbols bound to additional functions and condition types.

 -- Generic Function: readtablep [eclector.readtable] object

     This function is the generic version of the standard Common Lisp
     function cl:readtablep.  The function returns true if OBJECT can be
     used as a readtable in Eclector via the protocol functions in the
     ecelctor.readtable package.  The default method returns nil.

   TODO


File: eclector.info,  Node: Parse result construction features,  Next: CST reader features,  Prev: Readtable features,  Up: External protocols

2.5 Parse result construction features
======================================

In this section, symbols written without package marker are in the
eclector.parse-result package (*note Package for parse result
construction features::).

   This package provides clients with a reader that behaves similarly to
cl:read but returns custom parse result objects controlled by the
client.  Some parse results correspond to things like symbols, numbers
and lists that cl:read would return, while others, if the client
chooses, represent comments and other kinds of input that cl:read would
discard.  Furthermore, clients can associate source location information
with parse results.

   Clients using this package pass a “client” instance for which methods
on the generic functions described below are applicable to read,
read-preserving-whitespace or read-from-string.  Suitable client classes
can be constructed by using parse-result-client as a superclass and at
least defining a method on the generic function make-expression-result.

            [image src="read-call-sequence-parse-result.png" ]

Figure 2.3: Functions and typical function call sequences.  Solid arrows
represent calls, dashed arrows represent returns from function calls.
Labels above arrows represent arguments and return values.  Differences
from the non-parse result version are highlighted with bold text.

   *note Figure 2.3: fig:read-call-sequence-parse-result. shows typical
function call patterns that arise when the functions read,
read-preserving-whitespace, read-from-string and read-delimited-list are
called by client code.

 -- Function: read [eclector.parse-result] client &optional
          (input-stream *standard-input*) (eof-error-p t) (eof-value
          nil)

     This function is the main entry point for this variant of the
     reader.  It is in many ways similar to the standard Common Lisp
     function cl:read.  The differences are:

        • A client instance must be supplied as the first argument.

        • The first return value, unless EOF-VALUE is returned, is an
          arbitrary parse result object created by the client, not
          generally the read object.

        • The second return value, unless EOF-VALUE is returned, is a
          list of “orphan” results.  These results are return values of
          make-skipped-input-result and arise when skipping input at the
          toplevel such as comments which are not lexically contained in
          lists: #|orphan|# (#|not orphan|#).

        • The function does not accept a RECURSIVE parameter since it
          sets up a dynamic environment in which calls to
          eclector.reader:read behave suitably.

 -- Function: read-preserving-whitespace [eclector.parse-result] client
          &optional (input-stream *standard-input*) (eof-error-p t)
          (eof-value nil)

     This function is similar to the standard Common Lisp function
     cl:read-preserving-whitespace.  The differences are the same as
     described above for read compared to cl:read.

 -- Function: read-from-string [eclector.parse-result] client string
          &optional (eof-error-p t) (eof-value nil) &key (start 0) (end
          nil) (preserve-whitespace nil)

     This function is similar to the standard Common Lisp function
     cl:read-from-string.  The differences are:

        • A client instance must be supplied as the first argument.

        • The first return value, unless EOF-VALUE is returned, is an
          arbitrary parse result object created by the client, not
          generally the read object.

        • The _third_ return value, unless EOF-VALUE is returned, is a
          list of “orphan” results (Described above).

 -- Class: parse-result-client [eclector.parse-result]

     This class should generally be used as a superclass for client
     classes using this package.

 -- Generic Function: make-expression-result [eclector.parse-result]
          client result children source

     This generic function is called in order to construct a parse
     result object.  The value of the RESULT parameter is the raw object
     read.  The value of the CHILDREN parameter is a list of already
     constructed parse result objects representing objects read by
     recursive read calls.  The value of the SOURCE parameter is a
     source range, as returned by eclector.base:make-source-range and
     eclector.base:source-position delimiting the range of characters
     from which RESULT has been read.

     This generic function does not have a default method since the
     purpose of the package is the construction of _custom_ parse
     results.  Thus, a client must define a method on this generic
     function.

 -- Generic Function: make-skipped-input-result [eclector.parse-result]
          client stream reason source

     This generic function is called after the reader skipped over a
     range of characters in STREAM.  It returns either nil if the
     skipped input should not be represented or a client-specific
     representation of the skipped input.  The value of the SOURCE
     parameter designates the skipped range using a source range
     representation obtained via make-source-range and source-position.

     Reasons for skipping input include comments, the #+ and #- reader
     macros and *read-suppress*.  The aforementioned reasons are
     reflected by the value of the REASON parameter as follows:

     Input                                Value of the REASON parameter
     --------------------------------------------------------------------------
     Comment starting with ;              (:line-comment . 1)
     Comment starting with ;;             (:line-comment . 2)
     Comment starting with n ;            (:line-comment . n)
     Comment delimited by #| |#           :block-comment
     #+_false-expression_                 (:sharpsign-plus .
                                          _false-expression_)
     #-_true-expression_                  (:sharpsign-minus .
                                          _true-expression_)
     *read-suppress* is true              *read-suppress*
     A reader macro returns no values     :reader-macro

     The default method returns nil, that is the skipped input is not
     represented as a parse result.


File: eclector.info,  Node: CST reader features,  Prev: Parse result construction features,  Up: External protocols

2.6 CST reader features
=======================

In this section, symbols written without package marker are in the
eclector.concrete-syntax-tree package (*note Package for CST
features::).

 -- Function: read [eclector.concrete-syntax-tree] &optional
          (input-stream *standard-input*) (eof-error-p t) (eof-value
          nil)

     This function is the main entry point for the CST reader.  It is
     mostly compatible with the standard Common Lisp function cl:read.
     The differences are:

        • The return value, unless EOF-VALUE is returned, is an instance
          of a subclass of concrete-syntax-tree:cst.

        • The function does not accept a RECURSIVE parameter since it
          sets up a dynamic environment in which calls to
          eclector.reader:read behave suitably.

 -- Function: read-preserving-whitespace [eclector.concrete-syntax-tree]
          &optional (input-stream *standard-input*) (eof-error-p t)
          (eof-value nil)

     This function is similar to the standard Common Lisp function
     cl:read-preserving-whitespace.  The differences are the same as
     described above for read compared to cl:read.

 -- Function: read-from-string [eclector.concrete-syntax-tree] string
          &optional (eof-error-p t) (eof-value nil) &key (start 0) (end
          nil) (preserve-whitespace nil)

     This function is similar to the standard Common Lisp function
     cl:read-from-string.  The differences are the same as described
     above for read compared to cl:read.


File: eclector.info,  Node: Recovering from errors,  Next: Side effects,  Prev: External protocols,  Up: Top

3 Recovering from errors
************************

* Menu:

* Error recovery features::
* Recoverable errors::
* Potential problems::


File: eclector.info,  Node: Error recovery features,  Next: Recoverable errors,  Up: Recovering from errors

3.1 Error recovery features
===========================

Eclector offers extensive support for recovering from many syntax
errors, continuing to read from the input stream and return a result
that somewhat resembles what would have been returned in case the syntax
had been valid.  To this end, a restart named eclector.reader:recover is
established when recoverable errors are signaled.  Like the standard
Common Lisp restart cl:continue, this restart can be invoked by a
function of the same name:

 -- Function: recover [eclector.reader] &optional condition

     This function recovers from an error by invoking the most recently
     established applicable restart named eclector.reader:recover.  If
     no such restart is currently established, it returns nil.  If
     CONDITION is non-nil, only restarts that are either explicitly
     associated with CONDITION, or not associated with any condition are
     considered.

   When a read call during which error recovery has been performed
returns, Eclector tries to return an object that is similar in terms of
type, numeric value, sequence length, etc.  to what would have been
returned in case the input had been well-formed.  For example,
recovering after encountering the invalid digit in #b11311 returns
either the number #b11011 or the number #b11111.


File: eclector.info,  Node: Recoverable errors,  Next: Potential problems,  Prev: Error recovery features,  Up: Recovering from errors

3.2 Recoverable errors
======================

A syntax error and a corresponding recovery strategy are characterized
by the type of the signaled condition and the report of the established
eclector.reader:recover restart respectively.  Attempting to list and
describe all examples of both would provide little insight.  Instead,
this section describes different classes of errors and corresponding
recovery strategies in broad terms:

   • Replace a missing numeric macro parameter or ignore an invalid
     numeric macro parameter.  Examples: #=1 ⟶ 1, #5P"." ⟶ #P"."

   • Add a missing closing delimiter.  Examples: "foo ⟶ "foo", (1 2 ⟶ (1
     2), #(1 2 ⟶ #(1 2), #C(1 2 ⟶ #C(1 2)

   • Replace an invalid digit or an invalid number with a valid one.
     This includes digits which are invalid for a given base but also
     things like 0 denominator.  Examples: #12rc ⟶ 1, 1/0 ⟶ 1, #C(1
     :foo) ⟶ #C(1 1)

   • Replace an invalid character with a valid one.  Example: #\foo ⟶
     #\?

   • Invalid constructs can sometimes be ignored.  Examples: (,1) ⟶ (1),
     #S(foo :bar 1 2 3) ⟶ #S(foo :bar 1)

   • Excess parts can often be ignored.  Examples: #C(1 2 3) ⟶ #C(1 2),
     #2(1 2 3) ⟶ #2(1 2)

   • Replace an entire construct by some fallback value.  Example: #S(5)
     ⟶ nil, (#1=) ⟶ (nil)


File: eclector.info,  Node: Potential problems,  Prev: Recoverable errors,  Up: Recovering from errors

3.3 Potential problems
======================

Note that attempting to recover from syntax errors may lead to apparent
success in the sense that the read call returns an object, but this
object may not be what the caller wanted.  For example, recovering from
the missing closing " in the following example

     (defun foo (x y)
       "My documentation string
       (+ x y))

   results in ‘(DEFUN FOO (X Y) "My documentation string<newline> (+ x
y))")’, not ‘(DEFUN FOO (X Y) "My documentation string" (+ x y))’.


File: eclector.info,  Node: Side effects,  Next: Interpretation of Unclear Parts of the Specifications,  Prev: Recovering from errors,  Up: Top

4 Side effects
**************

This chapter describes potential side effects of calling
eclector.reader:read, eclector.reader:read-preserving-whitespace or
eclector.reader:read-from-string for different kinds of clients.

* Menu:

* Potential side effects for the default client::
* Potential side effects for non-default clients::


File: eclector.info,  Node: Potential side effects for the default client,  Next: Potential side effects for non-default clients,  Up: Side effects

4.1 Potential side effects for the default client
=================================================

The following destructive modifications are considered uninteresting and
ignored in the remainder of this section:

   • Changes to the state of streams passed to the functions mentioned
     above.

   • Changes to objects within expressions currently being read.

   Furthermore, the remainder of this section is written under the
following assumptions:

   • The stream object passed to eclector.reader:read does not cause
     additional side effects on its own.

   • The variable eclector.reader:*client* is bound to an object for
     which there are no custom applicable methods on generic functions
     belonging to protocols provided by Eclector that introduce
     additional side effects.

   • The variable eclector.readtable:*readtable* is bound to an object
     for which

        • there are no custom applicable methods on generic functions
          belonging to protocols provided by Eclector that introduce
          additional side effects

        • no non-default macro functions have been installed

   If any of the above assumptions does not hold, “all bets are off” in
the sense that arbitrary side effects other than the ones described
below are possible.  For notes regarding non-default clients, *Note
Potential side effects for non-default clients::.

* Menu:

* Symbols and packages (default client)::
* Read-time evaluation (default client)::
* Standard reader macros (default client)::


File: eclector.info,  Node: Symbols and packages (default client),  Next: Read-time evaluation (default client),  Up: Potential side effects for the default client

4.1.1 Symbols and packages (default client)
-------------------------------------------

The default method on the generic function
eclector.reader:interpret-symbol may create and intern symbols, thereby
modifying the package system.


File: eclector.info,  Node: Read-time evaluation (default client),  Next: Standard reader macros (default client),  Prev: Symbols and packages (default client),  Up: Potential side effects for the default client

4.1.2 Read-time evaluation (default client)
-------------------------------------------

The default method on the generic function
eclector.reader:evaluate-expression uses cl:eval to evaluate arbitrary
expressions, potentially causing side effects.  With the default
readtable, the generic function is only called by the macro function of
the #. reader macro.


File: eclector.info,  Node: Standard reader macros (default client),  Prev: Read-time evaluation (default client),  Up: Potential side effects for the default client

4.1.3 Standard reader macros (default client)
---------------------------------------------

The default method on the generic function
eclector.reader:call-reader-macro can cause side effects by calling
macro functions that cause side effects.  The following standard reader
macros potentially cause side-effects:

   • #. as described in *note Read-time evaluation (default client)::.


File: eclector.info,  Node: Potential side effects for non-default clients,  Prev: Potential side effects for the default client,  Up: Side effects

4.2 Potential side effects for non-default clients
==================================================

* Menu:

* Symbols and packages::
* Read-time evaluation::
* Structure instance creation::
* Circular structure::
* Standard reader macros::


File: eclector.info,  Node: Symbols and packages,  Next: Read-time evaluation,  Up: Potential side effects for non-default clients

4.2.1 Symbols and packages
--------------------------

In addition to the potential side effects described in *note Symbols and
packages (default client)::, strings passed as the third argument of
eclector.reader:interpret-token are potentially destructively modified
during conversion to the current readtable case.


File: eclector.info,  Node: Read-time evaluation,  Next: Structure instance creation,  Prev: Symbols and packages,  Up: Potential side effects for non-default clients

4.2.2 Read-time evaluation
--------------------------

The same considerations as in *note Read-time evaluation (default
client):: apply.


File: eclector.info,  Node: Structure instance creation,  Next: Circular structure,  Prev: Read-time evaluation,  Up: Potential side effects for non-default clients

4.2.3 Structure instance creation
---------------------------------

Clients defining methods on eclector.reader:make-structure-instance
which implement the standard behavior of calling the default constructor
(if any) of the named structure should consider side effects caused by
slot initforms of the structure.  The following example illustrates this
problem:
       (defvar *counter* 0)
       (defstruct foo (bar (incf *counter*)))
       #S(foo)
       *counter* ; => 1
       #S(foo)
       *counter* ; => 2


File: eclector.info,  Node: Circular structure,  Next: Standard reader macros,  Prev: Structure instance creation,  Up: Potential side effects for non-default clients

4.2.4 Circular structure
------------------------

The fixup generic function potentially modifies its second argument
destructively.  Clients that define methods on
eclector.reader:make-structure-instance should be aware of this
potential modification in cases like #1=#S(foo :bar #1#).  Similar
considerations apply for other ways of constructing compound objects
such as #1=(t . #1#).


File: eclector.info,  Node: Standard reader macros,  Prev: Circular structure,  Up: Potential side effects for non-default clients

4.2.5 Standard reader macros
----------------------------

The following standard reader macros could cause or be affected by side
effects when combined with a non-standard client:

   • #. as described in *note Read-time evaluation (default client)::.

   • #S as described in *note Structure instance creation::.

   • (, #( and #S as described in *note Circular structure::.

   • The ,. (i.e.  destructively splicing) variant of the , reader macro
     does not currently destructively modify the surrounding object, but
     clients should not rely on this fact.  This consideration applies
     to clients that install non-standard macro functions for the ( and
     #( reader macros.


File: eclector.info,  Node: Interpretation of Unclear Parts of the Specifications,  Next: Concept index,  Prev: Side effects,  Up: Top

5 Interpretation of Unclear Parts of the Specifications
*******************************************************

This chapter describes Eclector’s interpretation of passages in the
Common Lisp specification that do not describe the behavior of a
conforming reader completely unambiguously.

* Menu:

* Interpretation of Sharpsign C and Sharpsign S::
* Interpretation of Backquote and Sharpsign Single Quote::


File: eclector.info,  Node: Interpretation of Sharpsign C and Sharpsign S,  Next: Interpretation of Backquote and Sharpsign Single Quote,  Up: Interpretation of Unclear Parts of the Specifications

5.1 Interpretation of Sharpsign C and Sharpsign S
=================================================

At first glance, Sharpsign C and Sharpsign S seem to follow the same
syntactic structure: the dispatch macro character followed by the
sub-character followed by a list of a specific structure.  However, the
actual descriptions of the respective syntax is different.  For
Sharpsign C, the specification states:

     #C reads a following object, which must be a list of length two
     whose elements are both reals.

   For Sharpsign S, on the other hand, the specification describes the
syntax as:

     #s(NAME SLOT1 VALUE1 SLOT2 VALUE2 ...) denotes a structure.

   Note how the description for Sharpsign C relies on a recursive read
invocation while the description for Sharpsign S gives a character-level
pattern with meta-syntactic variables.  It is possible that this is an
oversight and the syntax was intended to be uniform between the two
reader macros.  Whatever the case may be, in order to provide conforming
behavior, Eclector is forced to implement Sharpsign C with a recursive
read invocation and Sharpsign S with a stricter enforcement of the
specified syntax.

   More concretely, Eclector behaves as summarized in the following
table:

Input                                Behavior
--------------------------------------------------------------------------
#C(1 2)                              Read as #C(1 2)
#C (1 2)                             Read as #C(1 2)
#C#||#(1 2)                          Read as #C(1 2)
#C#.(list 1 (+ 2 3))                 Read as #C(1 5)
#C[1 2] for left-parenthesis         Read as #C(1 2)
syntax on [                          
#S(foo)                              Read as #S(foo)
#S (foo)                             Rejected
#S#||#(foo)                          Rejected
#S#.(list 'foo)                      Rejected
#S[foo] for left-parenthesis         Rejected
syntax on [

   Eclector provides a strict version of the Sharpsign C macro function
under the name eclector.reader:strict-sharpsign-c which behaves as
follows:

Input                                Behavior
--------------------------------------------------------------------------
#C(1 2)                              Read as #C(1 2)
#C (1 2)                             Rejected
#C#||#(1 2)                          Rejected
#C#.(list 1 (+ 2 3))                 Rejected
#C[1 2] for left-parenthesis         Read as #C(1 2)
syntax on [


File: eclector.info,  Node: Interpretation of Backquote and Sharpsign Single Quote,  Prev: Interpretation of Sharpsign C and Sharpsign S,  Up: Interpretation of Unclear Parts of the Specifications

5.2 Interpretation of Backquote and Sharpsign Single Quote
==========================================================

The Common Lisp specification is very specific about the contexts in
which the quasiquotation mechanism can be used.  Explicit descriptions
of the behavior of the quasiquotation mechanism are given for
expressions which _are_ lists or vectors and it is implied that unquote
is not allowed in other expressions.  From this description, it is clear
that `#S(foo :bar ,x) is not valid syntax, for example.  However,
whether `#',foo is valid syntax depends on whether #'THING is considered
to _be_ a list.  Since `#',foo is a relatively common idiom, Eclector
accepts it by default.

   Eclector provides a strict version of the Sharpsign Single Quote
macro function under the name
eclector.reader:strict-sharpsign-single-quote which does not accept
unquote in the function name.


File: eclector.info,  Node: Concept index,  Next: Function and macro and variable and type index,  Prev: Interpretation of Unclear Parts of the Specifications,  Up: Top

Concept index
*************

 [index ]
* Menu:

* client:                                Basic features.       (line  6)
* client <1>:                            Parse result construction features.
                                                               (line  6)
* complex literal:                       Interpretation of Sharpsign C and Sharpsign S.
                                                               (line  6)
* concrete syntax tree:                  Introduction.         (line  6)
* concrete syntax tree <1>:              Package for CST features.
                                                               (line  6)
* concrete syntax tree <2>:              CST reader features.  (line  6)
* error:                                 Recovering from errors.
                                                               (line  6)
* function:                              S-expression creation and quasiquotation.
                                                               (line 67)
* function <1>:                          Interpretation of Backquote and Sharpsign Single Quote.
                                                               (line  6)
* parse result:                          Introduction.         (line  6)
* parse result <1>:                      Package for parse result construction features.
                                                               (line  6)
* parse result <2>:                      Package for CST features.
                                                               (line  6)
* parse result <3>:                      Ordinary reader features.
                                                               (line  6)
* parse result <4>:                      Parse result construction features.
                                                               (line  6)
* parse result <5>:                      CST reader features.  (line  6)
* quasiquotation:                        S-expression creation and quasiquotation.
                                                               (line 18)
* quasiquote:                            Interpretation of Backquote and Sharpsign Single Quote.
                                                               (line  6)
* quotation:                             S-expression creation and quasiquotation.
                                                               (line  6)
* reader macro:                          Interpretation of Sharpsign C and Sharpsign S.
                                                               (line  6)
* reader macro <1>:                      Interpretation of Backquote and Sharpsign Single Quote.
                                                               (line  6)
* readtable:                             Package for readtable features.
                                                               (line  6)
* readtable <1>:                         Readtable initialization.
                                                               (line  6)
* readtable <2>:                         Readtable features.   (line  6)
* recovery:                              Recovering from errors.
                                                               (line  6)
* side effects:                          Side effects.         (line  6)
* source location:                       Basic features.       (line  6)
* source tracking:                       Introduction.         (line  6)
* source tracking <1>:                   Ordinary reader features.
                                                               (line  6)
* specification interpretation:          Interpretation of Unclear Parts of the Specifications.
                                                               (line  6)
* structure literal:                     Interpretation of Sharpsign C and Sharpsign S.
                                                               (line  6)


File: eclector.info,  Node: Function and macro and variable and type index,  Prev: Concept index,  Up: Top

Function and macro and variable and type index
**********************************************

 [index ]
* Menu:

* *client* [eclector.base]:              Basic features.      (line  37)
* *skip-reason* [eclector.reader]:       Reader behavior protocol.
                                                              (line  95)
* call-as-top-level-read [eclector.reader]: Reader behavior protocol.
                                                              (line  23)
* call-reader-macro [eclector.reader]:   Reader behavior protocol.
                                                              (line 218)
* call-with-current-package [eclector.reader]: Reader behavior protocol.
                                                              (line 260)
* check-feature-expression [eclector.reader]: Reader behavior protocol.
                                                              (line 288)
* check-symbol-token [eclector.reader]:  Reader behavior protocol.
                                                              (line 136)
* evaluate-expression [eclector.reader]: Reader behavior protocol.
                                                              (line 275)
* evaluate-feature-expression [eclector.reader]: Reader behavior protocol.
                                                              (line 304)
* find-character [eclector.reader]:      Reader behavior protocol.
                                                              (line 234)
* fixup [eclector.reader]:               Reader behavior protocol.
                                                              (line 326)
* interpret-symbol [eclector.reader]:    Reader behavior protocol.
                                                              (line 190)
* interpret-symbol-token [eclector.reader]: Reader behavior protocol.
                                                              (line 172)
* interpret-token [eclector.reader]:     Reader behavior protocol.
                                                              (line 118)
* make-expression-result [eclector.parse-result]: Parse result construction features.
                                                              (line  89)
* make-skipped-input-result [eclector.parse-result]: Parse result construction features.
                                                              (line 106)
* make-source-range [eclector.base]:     Basic features.      (line  58)
* make-structure-instance [eclector.reader]: Reader behavior protocol.
                                                              (line 242)
* note-skipped-input [eclector.reader]:  Reader behavior protocol.
                                                              (line  77)
* parse-result-client [eclector.parse-result]: Parse result construction features.
                                                              (line  84)
* read [eclector.concrete-syntax-tree]:  CST reader features. (line  10)
* read [eclector.parse-result]:          Parse result construction features.
                                                              (line  36)
* read [eclector.reader]:                Common Lisp reader compatible interface.
                                                              (line  12)
* read-common [eclector.reader]:         Reader behavior protocol.
                                                              (line  41)
* read-delimited-list [eclector.reader]: Common Lisp reader compatible interface.
                                                              (line  34)
* read-from-string [eclector.concrete-syntax-tree]: CST reader features.
                                                              (line  33)
* read-from-string [eclector.parse-result]: Parse result construction features.
                                                              (line  68)
* read-from-string [eclector.reader]:    Common Lisp reader compatible interface.
                                                              (line  27)
* read-maybe-nothing [eclector.reader]:  Reader behavior protocol.
                                                              (line  52)
* read-preserving-whitespace [eclector.concrete-syntax-tree]: CST reader features.
                                                              (line  25)
* read-preserving-whitespace [eclector.parse-result]: Parse result construction features.
                                                              (line  60)
* read-preserving-whitespace [eclector.reader]: Common Lisp reader compatible interface.
                                                              (line  20)
* read-token [eclector.reader]:          Reader behavior protocol.
                                                              (line 110)
* readtablep [eclector.readtable]:       Readtable features.  (line  19)
* recover [eclector.reader]:             Error recovery features.
                                                              (line  14)
* set-standard-dispatch-macro-characters [eclector.reader]: Readtable initialization.
                                                              (line  21)
* set-standard-macro-characters [eclector.reader]: Readtable initialization.
                                                              (line  16)
* set-standard-syntax-and-macros [eclector.reader]: Readtable initialization.
                                                              (line  28)
* set-standard-syntax-types [eclector.reader]: Readtable initialization.
                                                              (line  11)
* source-position [eclector.base]:       Basic features.      (line  46)
* stream-position [eclector.base]:       Basic features.      (line  26)
* stream-position-condition [eclector.base]: Basic features.  (line  16)
* with-forbidden-quasiquotation [eclector.reader]: S-expression creation and quasiquotation.
                                                              (line  53)
* wrap-in-function [eclector.reader]:    S-expression creation and quasiquotation.
                                                              (line  67)
* wrap-in-quasiquote [eclector.reader]:  S-expression creation and quasiquotation.
                                                              (line  18)
* wrap-in-quote [eclector.reader]:       S-expression creation and quasiquotation.
                                                              (line   9)
* wrap-in-unquote [eclector.reader]:     S-expression creation and quasiquotation.
                                                              (line  27)
* wrap-in-unquote-splicing [eclector.reader]: S-expression creation and quasiquotation.
                                                              (line  36)



Tag Table:
Node: Top296
Node: Introduction677
Ref: Introduction-Footnote-11787
Node: External protocols1859
Node: Packages2171
Node: Package for basic features2483
Node: Package for ordinary reader features2945
Node: Package for readtable features3541
Node: Package for parse result construction features4149
Node: Package for CST features4819
Node: Basic features5407
Ref: Class eclector.base|stream-position-condition6096
Ref: Generic-Function eclector.base|stream-position6591
Ref: Variable eclector.base|*client*7074
Ref: Generic-Function eclector.base|source-position7526
Ref: Generic-Function eclector.base|make-source-range8096
Node: Ordinary reader features8559
Ref: fig:read-call-sequence-ordinary9677
Node: Common Lisp reader compatible interface10447
Ref: Function eclector.reader|read10967
Ref: Function eclector.reader|read-preserving-whitespace11282
Ref: Function eclector.reader|read-from-string11561
Ref: Function eclector.reader|read-delimited-list11838
Node: Reader behavior protocol12073
Ref: fig:read-call-sequence-customization12445
Ref: Generic-Function eclector.reader|call-as-top-level-read13099
Ref: Generic-Function eclector.reader|read-common14017
Ref: Generic-Function eclector.reader|read-maybe-nothing14545
Ref: Generic-Function eclector.reader|note-skipped-input15688
Ref: Variable eclector.reader|*skip-reason*16643
Ref: Generic-Function eclector.reader|read-token17427
Ref: Generic-Function eclector.reader|interpret-token17813
Ref: Generic-Function eclector.reader|check-symbol-token18870
Ref: Generic-Function eclector.reader|interpret-symbol-token20743
Ref: Generic-Function eclector.reader|interpret-symbol21734
Ref: Generic-Function eclector.reader|call-reader-macro22950
Ref: Generic-Function eclector.reader|find-character23778
Ref: Generic-Function eclector.reader|make-structure-instance24139
Ref: Generic-Function eclector.reader|call-with-current-package24977
Ref: Generic-Function eclector.reader|evaluate-expression25691
Ref: Generic-Function eclector.reader|check-feature-expression26256
Ref: Generic-Function eclector.reader|evaluate-feature-expression27082
Ref: Generic-Function eclector.reader|fixup28165
Node: S-expression creation and quasiquotation29291
Ref: Generic-Function eclector.reader|wrap-in-quote29664
Ref: Generic-Function eclector.reader|wrap-in-quasiquote30022
Ref: Generic-Function eclector.reader|wrap-in-unquote30392
Ref: Generic-Function eclector.reader|wrap-in-unquote-splicing30747
Ref: Macro eclector.reader|with-forbidden-quasiquotation31501
Ref: Generic-Function eclector.reader|wrap-in-function32253
Node: Readtable initialization32625
Ref: Function eclector.reader|set-standard-syntax-types33073
Ref: Function eclector.reader|set-standard-macro-characters33242
Ref: Function eclector.reader|set-standard-dispatch-macro-characters33417
Ref: Function eclector.reader|set-standard-syntax-and-macros33670
Node: Readtable features33872
Ref: Generic-Function eclector.readtable|readtablep34633
Node: Parse result construction features34985
Ref: fig:read-call-sequence-parse-result36166
Ref: Function eclector.parse-result|read36742
Ref: Function eclector.parse-result|read-preserving-whitespace37837
Ref: Function eclector.parse-result|read-from-string38192
Ref: Class eclector.parse-result|parse-result-client38871
Ref: Generic-Function eclector.parse-result|make-expression-result39029
Ref: Generic-Function eclector.parse-result|make-skipped-input-result39878
Node: CST reader features41459
Ref: Function eclector.concrete-syntax-tree|read41769
Ref: Function eclector.concrete-syntax-tree|read-preserving-whitespace42391
Ref: Function eclector.concrete-syntax-tree|read-from-string42747
Node: Recovering from errors43109
Node: Error recovery features43356
Ref: Function eclector.reader|recover43968
Node: Recoverable errors44785
Node: Potential problems46277
Node: Side effects46908
Node: Potential side effects for the default client47388
Node: Symbols and packages (default client)49081
Node: Read-time evaluation (default client)49483
Node: Standard reader macros (default client)50060
Node: Potential side effects for non-default clients50619
Node: Symbols and packages51015
Node: Read-time evaluation51467
Node: Structure instance creation51776
Node: Circular structure52460
Node: Standard reader macros53019
Node: Interpretation of Unclear Parts of the Specifications53853
Node: Interpretation of Sharpsign C and Sharpsign S54403
Node: Interpretation of Backquote and Sharpsign Single Quote57060
Node: Concept index58156
Node: Function and macro and variable and type index62250

End Tag Table


Local Variables:
coding: utf-8
End:
